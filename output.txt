{'comment': '// JUnit 4 wraps solo tests this way. We can extract // the original test name with a little hack.', 'code': 'String name = test.toString();', 'label': 1}
{'comment': '// XXX ignore attributes in a different NS ( maybe store them ? )', 'code': 'String name = test.toString();', 'label': 1}
{'comment': '//borrowed from TokenFilterTest', 'code': 'throw new SAXParseException("Unexpected attribute \\"" + attrs.getQName(i) + "\\"", context.locator);', 'label': 1}
{'comment': '// XXX Move to Project ( so it is shared by all helpers )', 'code': 'private String getFileString(String filename) throws IOException {', 'label': 1}
{'comment': '// What is the property supposed to be?', 'code': 'String antFileProp = "ant.file." + context.getCurrentProjectName();', 'label': 1}
{'comment': '// PR: Hack for ant-type value //  an ant-type is a component name which can // be namespaced, need to extract the name // and convert from qualified name to uri/name', 'code': 'propertyValue =', 'label': 1}
{'comment': "// there's a convenient xsltc class version but data are // private so use package information", 'code': 'if (ANT_TYPE.equals(name)', 'label': 1}
{'comment': '// stolen from org.apache.xerces.impl.XMLEntityManager#getUserDir() // of the Xerces-J team // which ASCII characters need to be escaped', 'code': 'Class procVersion = Class.forName(procVersionClassName);', 'label': 1}
{'comment': '// bingo append it. (this should normally not be done here)', 'code': 'private static boolean[] gNeedEscaping = new boolean[128];', 'label': 1}
{'comment': '// This is faintly ridiculous:', 'code': 'parent.appendChild(copy);', 'label': 1}
{'comment': '//cannot remove underscores due to protected visibility >:(', 'code': 'ze.setCrc (EMPTY_CRC);', 'label': 1}
{'comment': '// TODO not read, yet in a public setter', 'code': 'protected String str_encoding = "JPEG";', 'label': 1}
{'comment': '//  PR: I do not know what to do if the object class //      has multiple defines //      but this is for logging only...', 'code': 'private long granularity = FILE_UTILS.getFileTimestampGranularity();', 'label': 1}
{'comment': '// not sure what could be the need of this...', 'code': 'Class elementClass = o.getClass();', 'label': 1}
{'comment': '// Experimental/Testing, will be removed', 'code': 'res.setSystemId(JAXPUtils.getSystemId(outfile));', 'label': 1}
{'comment': '// XXX should instead make a new ProtectionDomain with a CodeSource // corresponding to container.toURI().toURL() and the same // PermissionCollection as Project.class.protectionDomain had', 'code': 'if( name.startsWith( "toString:" )) {', 'label': 1}
{'comment': '//this is really irritating; we need a way to set stuff', 'code': 'return defineClass(classname, classData, 0, classData.length,', 'label': 1}
{'comment': '//XXX // All this to convert source to destination directory according // to weblogic standards Can be written better... this is too hacky!', 'code': 'String []args = cmd.getJavaCommand().getArguments();', 'label': 1}
{'comment': '//silly hack to avoid stack overflow...', 'code': 'jspFile = new File(files[i]);', 'label': 1}
{'comment': '// XXX - should throw an exception instead?', 'code': 'if (!readingFiles) {', 'label': 1}
{'comment': '// Temporary - until we figure a better API', 'code': "result.append('\\\\');", 'label': 1}
{'comment': "// There is a better way to save the context. This shouldn't // delegate to next, it's for backward compatibility only.", 'code': '/** EXPERIMENTAL WILL_CHANGE', 'label': 1}
{'comment': '// quick fix for Ant.java use of property before // initializing the project', 'code': "// delegate to next, it's for backward compat only.", 'label': 1}
{'comment': "// XXX: we should use JCVS (www.ice.com/JCVS) instead of // command line execution so that we don't rely on having // native CVS stuff around (SM)", 'code': 'addTaskDefinition(ANT_PROPERTY_TASK,', 'label': 1}
{'comment': '"/*             * two reasons are mentioned in the API docs for File.list             * (1) dir is not a directory. This is impossible as             *     we wouldn\'t get here in this case.             * (2) an IO error occurred (why doesn\'t it throw an exception             *     then???)             */"', 'code': "// We can't do it ourselves as jCVS is GPLed, a third party task", 'label': 1}
{'comment': '//     * @TODO using taskName here is brittle, as a user could override it. //     *       this should probably be modified to use the classname instead.', 'code': 'throw new BuildException("IO error scanning directory "', 'label': 1}
{'comment': '//these are pathological cases, but retained in case somebody //subclassed us.', 'code': 'if ("execon".equals(getTaskName())) {', 'label': 1}
{'comment': '// This is deprecated - use classespath in the future', 'code': 'return false;', 'label': 1}
{'comment': '//XXX  this array stuff is a remnant of prev trials.. gotta remove.', 'code': 'String[] sP = getSourcespath().list();', 'label': 1}
{'comment': '"/**     * Set the number of milliseconds leeway to give before deciding a     * target is out of date.     * TODO: This is not yet used.     * @param granularity the granularity used to decide if a target is out of     *                    date.     */"', 'code': 'args[j++] = "-d";', 'label': 1}
{'comment': '// This may change, if we add advanced parsing capabilities.', 'code': 'public void setGranularity(long granularity) {', 'label': 1}
{'comment': '// We assume, that every output, jikes does, stands for an error/warning // XXX // Is this correct?', 'code': 'parseStandardOutput(reader);', 'label': 1}
{'comment': '// The line below is a hack: the system id must an URI, but it is not // cleat to get the URI of an resource, so just set the name of the // resource as a system id', 'code': '// TODO:', 'label': 1}
{'comment': '// XXX what is the following doing? //     should it run if !javadoc4 && executable != null?', 'code': 'src.setSystemId(resourceToURI(resource));', 'label': 1}
{'comment': '// MAC OS 9 and previous //TODO: I have no idea how to get it, someone must fix it', 'code': 'if (javadoc4 && sourceFileName.indexOf(" ") > -1) {', 'label': 1}
{'comment': '//TODO: nothing appears to read this but is set using a public setter.', 'code': 'return null;', 'label': 1}
{'comment': '// XXX - we are committing CombiningChar and Extender here', 'code': 'private boolean spawn = false;', 'label': 1}
{'comment': '"/*                 * XXX - failed to load the class properly.                 *                 * should we print a warning here?                 */"', 'code': 'if (!Character.isLetterOrDigit(c)', 'label': 1}
{'comment': '// XXX could perhaps also call thread.stop(); not sure if anyone cares', 'code': 'return;', 'label': 1}
{'comment': '"/**         * XXX         * Perhaps we shouldn\'t use properties for these         * three options (emacs mode, warnings and pedantic),         * but include it in the javac directive?         */"', 'code': 'throw e;', 'label': 1}
{'comment': '// XXX maybe use reflection to addPathElement (other patterns ?)', 'code': '* Jikes has the nice feature to print error', 'label': 1}
{'comment': '// TODO there is a problem with the constructor for the RBC. // you have to provide the rules in the constructors - no setters // available.', 'code': 'if (obj != null && !(obj instanceof AntClassLoader)) {', 'label': 1}
{'comment': '// probably not the best choice, but it solves the problem of // relative paths in CLASSPATH', 'code': 'throw new BuildException("RuleBasedCollator not yet supported.");', 'label': 1}
{'comment': '// Fix for invalid characters. If you think of more add to the list.', 'code': "path = path.replace('\\\\', '/');", 'label': 1}
{'comment': '// Check it out; also ugly.', 'code': 'StringBuffer modifiedClassName = new StringBuffer(className.length());', 'label': 1}
{'comment': "//I can't get my head around this; is encoding treatment needed here?", 'code': '// Change the item to be checked out to a StarTeam File.', 'label': 1}
{'comment': '//quick & dirty, to make nested mapped p-sets work:', 'code': 'return', 'label': 1}
{'comment': '// XXX is this code still necessary? is there any 1.2+ port? // Pull in *.zip from packages directory', 'code': 'for (Enumeration e = setRefs.elements(); e.hasMoreElements();) {', 'label': 1}
{'comment': '// only: the developer knows what (s)he is doing', 'code': 'FileSet msZipFiles = new FileSet();', 'label': 1}
{'comment': '// first: developer could use a little help', 'code': 'result.addExisting(p, true);', 'label': 1}
{'comment': '// XXX     should we silently catch possible exceptions and try to //         load a different implementation?', 'code': 'result.addExisting(p, true);', 'label': 1}
{'comment': '// since Java 1.4 //return normalizedPath.split("/"); // workaround for Java 1.2-1.3', 'code': 'Throwable cause = null;', 'label': 1}
{'comment': '// HAMMER // end inline mainGTU', 'code': "Object[] tokens = StringUtils.split(normalizedPath, '/').toArray();", 'label': 1}
{'comment': '"/**     * This array really shouldn\'t be here.     * Again, for historical purposes it is.     *     * <p>FIXME: This array should be in a private or package private     * location, since it could be modified by malicious code.</p>     */"', 'code': 'fmap[j] = v;', 'label': 1}
{'comment': '// Should move to a separate public class - and have API to add // listeners, etc.', 'code': 'int[] rNums = {', 'label': 1}
{'comment': '// "" should become a single empty argument, same for \'\' // PR 5906', 'code': 'private static class AntRefTable extends Hashtable {', 'label': 1}
{'comment': '// not very nice but will do the job', 'code': 's = Commandline.translateCommandline("\\"\\" a");', 'label': 1}
{'comment': '// provide public visibility', 'code': 'fail("process interrupted in thread");', 'label': 1}
{'comment': '// not used, but public so theoretically must remain for BC?', 'code': 'public String resolveFile(String file) {', 'label': 1}
{'comment': "// super.validateAttributes(); // don't want to call this method", 'code': 'public void assertEqualContent(File expect, File result)', 'label': 1}
{'comment': '// XXX what is this for?', 'code': 'if (propertyFile != null) {', 'label': 1}
{'comment': '// We keep this, so we have something to delete in later tests :-)', 'code': '}', 'label': 1}
{'comment': '// *************  copied from ConcatTest  *************', 'code': '}', 'label': 1}
{'comment': '// not sure whether this is clean, but this method is // declared not to throw exceptions.', 'code': '// ------------------------------------------------------', 'label': 1}
{'comment': '// We just set the prefix for this fileset, and pass it up. // Do we need to do this? LH', 'code': 'throw new IllegalStateException("Could not convert URI to path: "', 'label': 1}
{'comment': '//why do we do nothing?', 'code': 'fs.setPrefix("META-INF/");', 'label': 1}
{'comment': '// This is the new, better way - use classespath instead // of sourcespath.  The code is currently the same - you // need class files in a directory to use this or jar files.', 'code': '/**', 'label': 1}
{'comment': '// XXX - why not simply new File(dir, filename)?', 'code': 'String[] cP = getClassespath().list();', 'label': 1}
{'comment': '// This is ugly; checking for the root folder.', 'code': 'File file = getProject().resolveFile(new File(dir, filename).getPath());', 'label': 1}
{'comment': '//TODO: Parameterise ?? //Call compiler as class... dont want to fork again //Use classic compiler -- can be parameterised?', 'code': 'Folder f = v.getRootFolder();', 'label': 1}
{'comment': '//XXX // All this to get package according to weblogic standards // Can be written better... this is too hacky! // Careful.. similar code in scanDir , but slightly different!!', 'code': 'args[j++] =  "-compilerclass";', 'label': 1}
{'comment': '//stolen from writeManifest', 'code': 'String filename = (String) filesToDo.elementAt(i);', 'label': 1}
{'comment': '"/* If the jarfile already exists then whack it and recreate it.             * Should probably think of a more elegant way to handle this             * so that in case of errors we don\'t leave people worse off             * than when we started =)             */"', 'code': 'super.zipFile(service.getAsStream(), zOut,', 'label': 1}
{'comment': '// XXX is the following really necessary? it is in the same thread group...', 'code': 'if (jarfile.exists()) {', 'label': 1}
{'comment': '// we have to find a cleaner way to put this output', 'code': 'project.registerThreadTask(thread, currentThreadTask);', 'label': 1}
{'comment': '// This is the old way and is deprecated - classespath is // the right way to do this and is above', 'code': '}', 'label': 1}
{'comment': "// For Script example that modifies id'ed tasks in other // targets to work. *very* Ugly // The reference is replaced by RuntimeConfigurable", 'code': 'String[] sP = getSourcespath().list();', 'label': 1}
{'comment': "// don't call super.close() because that reader is used // on other places ...", 'code': 'this.getOwningTarget().replaceChild(this, (Task)realThing);', 'label': 1}
{'comment': '// report error if something weird happens...this is diagnostic.', 'code': 'if (appendReader != null) {', 'label': 1}
{'comment': '// sorry - otherwise we will get a ClassCastException because the MockCache // is loaded by two different classloader ...', 'code': 'if (error != null) {', 'label': 1}
{'comment': "// ***HACK*** We ask the VM to create an instance // by voluntarily providing illegal arguments to force // the VM to run the class' static initializer, while // at the same time not running a valid constructor.", 'code': 'sel.setClassLoader(this.getClass().getClassLoader());', 'label': 1}
{'comment': '// Singleton for now, it may change ( per/classloader )', 'code': 'final Constructor[] cons = theClass.getDeclaredConstructors();', 'label': 1}
{'comment': "// XXX - shouldn't this always return false in isolated mode?", 'code': 'return singleton;', 'label': 1}
{'comment': '//TO DO : delete the file if it is not a valid file.', 'code': 'boolean useParentFirst = parentFirst;', 'label': 1}
{'comment': '"/** * TODO: * comment field doesn\'t include all options yet */"', 'code': 'String msg = "Exception while calling " + VERIFY + " Details: "', 'label': 1}
{'comment': '// Have to think about lazy initialization here...  JHM // comparator = new java.text.RuleBasedCollator();', 'code': '* Performs a ClearCase Unlock command.', 'label': 1}
{'comment': '// XXX - log an error?  throw an exception?', 'code': '} else {', 'label': 1}
{'comment': '// TODO: allow user to request the system or no parent', 'code': '}', 'label': 1}
{'comment': '//if there was any text before this, add it as a fragment //TODO, this check could be modified to go if pos>prev; //seems like this current version could stick empty strings //into the list', 'code': 'if (parent == null) {', 'label': 1}
{'comment': '// XXX add exceptions', 'code': 'if (pos > 0) {', 'label': 1}
{'comment': '// test a process that runs and failed', 'code': '} catch (Exception ex) {', 'label': 1}
{'comment': '// ignore', 'code': 'public void testFailed() throws Exception {', 'label': 0}
{'comment': '// process should abort', 'code': '}', 'label': 0}
{'comment': '// user:password@host:/path notation', 'code': 'watchdog.start(process);', 'label': 0}
{'comment': '"/*          * @param event the build event that is being logged.         */"', 'code': 'setUsername(uri.substring(0, indexOfColon));', 'label': 0}
{'comment': '// only track progress for files larger than 100kb in verbose mode', 'code': 'public void messageLogged(BuildEvent event) {', 'label': 0}
{'comment': "// Element doesn't handle text content", 'code': 'boolean trackProgress = getVerbose() && filesize > 102400;', 'label': 0}
{'comment': '// send "C0644 filesize filename", where filename should not include \'/\'', 'code': 'if (text.length() == 0) {', 'label': 0}
{'comment': '// ClearCase items', 'code': 'long filesize = localFile.length();', 'label': 0}
{'comment': '/* Assign actual codes for the tables. */', 'code': 'if (getReserved()) {', 'label': 0}
{'comment': '// -reserved', 'code': 'sendMTFValues3(nGroups, alphaSize);', 'label': 0}
{'comment': '/* size of the central directory   */', 'code': 'cmd.createArgument().setValue(FLAG_RESERVED);', 'label': 0}
{'comment': "// gcj doesn't support an extension dir (-extdir) // so we'll emulate it for compatibility and convenience.", 'code': '/* offset of start of central      */', 'label': 0}
{'comment': '// At this point we are probably in failure mode, but // try to use the bare URI as a last gasp', 'code': 'Path p = getBootClassPath();', 'label': 0}
{'comment': '// -unreserved', 'code': 'source.setInputSource(new InputSource(uri));', 'label': 0}
{'comment': '// DataType can have a "no arg" constructor or take a single // Project argument.', 'code': 'cmd.createArgument().setValue(FLAG_UNRESERVED);', 'label': 0}
{'comment': '// -out', 'code': 'ctor = newclass.getConstructor(new Class[0]);', 'label': 0}
{'comment': '// b may be 0 for success, //          1 for error, //          2 for fatal error,', 'code': 'getOutCommand(cmd);', 'label': 0}
{'comment': '// Not whitespace - fail', 'code': 'if (b == -1) {', 'label': 0}
{'comment': '// Fall tru', 'code': 'String msg = project.getElementName(element)', 'label': 0}
{'comment': '// -ndata', 'code': '}', 'label': 0}
{'comment': '// C0644 filesize filename - header for a regular file // T time 0 time 0\\n - present if perserve time. // D directory - this is the header for a directory.', 'code': 'cmd.createArgument().setValue(FLAG_NODATA);', 'label': 0}
{'comment': '// -version', 'code': 'ByteArrayOutputStream stream = new ByteArrayOutputStream();', 'label': 0}
{'comment': "//wince isn't really 9x, but crippled enough to //be a muchness. Ant doesnt run on CE, anyway.", 'code': 'cmd.createArgument().setValue(FLAG_VERSION);', 'label': 0}
{'comment': '// -nwarn', 'code': '|| OS_NAME.indexOf("ce") >= 0);', 'label': 0}
{'comment': '// if a label has been supplied and it is a revision label, use the raw // the view as the snapshot', 'code': 'cmd.createArgument().setValue(FLAG_NOWARN);', 'label': 0}
{'comment': "// Class doesn't have a String constructor but a decent factory method", 'code': '} else if (this.isUsingRevisionLabel()) {', 'label': 0}
{'comment': '/* total number of entries in      */', 'code': '} else if (java.lang.Class.class.equals(reflectedArg)) {', 'label': 0}
{'comment': '// Check for \\r, \\r\\n and \\r\\r\\n // Regard \\r\\r not followed by \\n as two lines', 'code': '/* the central dir on this disk    */ + 2', 'label': 0}
{'comment': '// // Success!  The xml-commons resolver library is // available, so use it. //', 'code': '++eolcount;', 'label': 0}
{'comment': '// it is a new file // set the revision but not the prevrevision', 'code': 'catalogResolver = new ExternalResolver(clazz, obj);', 'label': 0}
{'comment': '//catch script/ant mismatch with a meaningful message //we could ignore it, but there are likely to be other //version problems, so we stamp down on the configuration now', 'code': 'String filename = line.substring(0, index);', 'label': 0}
{'comment': "// don't know the type, should throw exception instead?", 'code': 'String msg = "Ant\'s Main method is being handed "', 'label': 0}
{'comment': '// char and Character get special treatment - take the first character', 'code': 'return false;', 'label': 0}
{'comment': '// do nothing', 'code': '} else if (java.lang.Character.class.equals(reflectedArg)) {', 'label': 0}
{'comment': '// scan base dirs to build up compile lists only if a // specific classname is not given', 'code': '}', 'label': 0}
{'comment': '// write a Properties file in each directory:', 'code': 'if (classname == null) {', 'label': 0}
{'comment': '// **   simple name specified   == parent dir + name', 'code': 'for (Iterator dirs = byDir.keySet().iterator(); dirs.hasNext();) {', 'label': 0}
{'comment': '// requires version 2 as we are going to store length info // in the data descriptor', 'code': 'while (searchParents && parent != null && parent.exists()) {', 'label': 0}
{'comment': '// the test runner that wrap the dummy formatter that interests us', 'code': 'writeOut(ZipShort.getBytes(20));', 'label': 0}
{'comment': '// CheckStyle:VisibilityModifier OFF - bc', 'code': 'private final static class TestRunner extends JUnitTestRunner {', 'label': 0}
{'comment': '// First try with Project.', 'code': '/** The base directory to be scanned. */', 'label': 0}
{'comment': '// // The ResourceLocation may specify a relative path for its // location attribute.  This is resolved using the appropriate // base. //', 'code': 'c = reflectedArg.getConstructor(new Class[] {Project.class, String.class});', 'label': 0}
{'comment': '// Can return null to represent the bootstrap class loader. // see API docs of Class.getClassLoader.', 'code': 'if (matchingEntry.getBase() != null) {', 'label': 0}
{'comment': '/* start of the central directory  */', 'code': 'if (l != null) {', 'label': 0}
{'comment': '//private static final int GET_ENTRY = 0;', 'code': '/* total number of entries in      */', 'label': 0}
{'comment': '// file comment', 'code': 'private static final int GET_FILE = 1;', 'label': 0}
{'comment': '//There were no revisions in this changelog //entry so lets move onto next file', 'code': 'String comm = ze.getComment();', 'label': 0}
{'comment': '//same date if dest timestamp is within granularity of the srcfile', 'code': 'status = GET_FILE;', 'label': 0}
{'comment': '// must be "add"', 'code': 'boolean sameDate;', 'label': 0}
{'comment': '// ---------------------------------------------------------- // somewhat arbitrary choices that are quite common for shared // installations // -----------------------------------------------------------', 'code': 'c.setValue("crlf");', 'label': 0}
{'comment': '// EnumeratedAttributes have their own helper class', 'code': '//   Helper methods', 'label': 0}
{'comment': '// selectors are implicitly ANDed in DirectoryScanner.  To // revert their logic we wrap them into a <none> selector // instead.', 'code': '} else if (EnumeratedAttribute.class.isAssignableFrom(reflectedArg)) {', 'label': 0}
{'comment': "// first off, make sure that we've got a srcdir and destdir", 'code': 'FileSelector[] s = syncTarget.getSelectors(getProject());', 'label': 0}
{'comment': '// ZIPs store time with a granularity of 2 seconds, round up', 'code': 'validate();', 'label': 0}
{'comment': '// viewpath', 'code': 'ze.setTime(dir.lastModified() + (roundUp ? 1999 : 0));', 'label': 0}
{'comment': '// ------------------------------------------------------ //   Helper methods - should be in BuildFileTest // -----------------------------------------------------', 'code': 'cmdl.createArgument().setValue(getViewPath());', 'label': 0}
{'comment': '// build the command line from what we got the format is // cleartool lsco [options...] [viewpath ...] // as specified in the CLEARTOOL.EXE help', 'code': 'private boolean hasScript(String test) {', 'label': 0}
{'comment': '// Check if list of files to check has been specified', 'code': 'Commandline commandLine = new Commandline();', 'label': 0}
{'comment': "// testNoCrash is the test invoked by the captureToSummary's junit task", 'code': 'if (!filesets.isEmpty()) {', 'label': 0}
{'comment': '// if the two substrings are longer than the original, then name // contains address - so reset the name to null', 'code': 'private static final String PASS_TEST = "testNoCrash";', 'label': 0}
{'comment': '//default', 'code': 'if (this.name.length() + this.address.length() > len) {', 'label': 0}
{'comment': '// log options used', 'code': '// if this class belongs to a package which has been', 'label': 0}
{'comment': '// dummy formatter just to catch the error', 'code': 'String enc = encoding == null ? "default" : encoding;', 'label': 0}
{'comment': "// we don't expect to find this", 'code': 'private final static class ResultFormatter implements JUnitResultFormatter {', 'label': 0}
{'comment': '// resolve relative paths through Project', 'code': 'loader.findClass("fubar");', 'label': 0}
{'comment': '//patch file into the fileset', 'code': '} else if (java.io.File.class.equals(reflectedArg)) {', 'label': 0}
{'comment': '// type value', 'code': 'fileset.setFile(file);', 'label': 0}
{'comment': '// bit3 set to signal, we use a data descriptor', 'code': 'getTypeValueCommand(cmd);', 'label': 0}
{'comment': '//underscores go in front of invalid start chars', 'code': 'writeOut(ZipShort.getBytes(8));', 'label': 0}
{'comment': '// use to scan own archive', 'code': 'assertMapped(mangler, "0.jsp", "_0_jsp");', 'label': 0}
{'comment': '"/** * Tests the {@link XSLTProcess} task. * XXX merge with {@link StyleTest}? * @since Ant 1.5 */"', 'code': 'private ZipScanner zs;', 'label': 0}
{'comment': '// it is a modified file // set the revision and the prevrevision', 'code': 'public void setLoaderRef(Reference r) {', 'label': 0}
{'comment': '"/*             * throw in drive letters             */"', 'code': 'String filename = line.substring(0, index);', 'label': 0}
{'comment': '//set our parent dir', 'code': 'String driveSpec = "C:";', 'label': 0}
{'comment': '"/*             * promised to eliminate consecutive slashes after drive letter.             */"', 'code': 'srcDir = file.getParentFile();', 'label': 0}
{'comment': '// -cfile', 'code': 'assertEqualsIgnoreDriveCase(driveSpec + "\\\\",', 'label': 0}
{'comment': '// avoid multiple configurations', 'code': 'getCommentFileCommand(cmd);', 'label': 0}
{'comment': '/** Version to use for addXXX and addConfiguredXXX */', 'code': 'boolean isConfigured = false;', 'label': 0}
{'comment': '// Compare the destination with the temp file', 'code': 'private class AddNestedCreator extends NestedCreator {', 'label': 0}
{'comment': '// SMTP auth only allowed with MIME mail', 'code': 'log("destFile exists", Project.MSG_DEBUG);', 'label': 0}
{'comment': '// All three specified and all three exist -> true', 'code': 'if (!autoFound && ((user != null) || (password != null))', 'label': 0}
{'comment': '// an address to send from is required', 'code': 'public void test10() {', 'label': 0}
{'comment': '// File is not found in specified filepath', 'code': 'if (from == null || from.getAddress() == null) {', 'label': 0}
{'comment': '// set the character set if not done already (and required)', 'code': 'public void testSearchInPathNotThere() {', 'label': 0}
{'comment': '// 2 is != 0 and even, so it is considered // failure on any platform currently supported // by Execute#isFailure.', 'code': 'if (charset != null) {', 'label': 0}
{'comment': '// Eof has been reached', 'code': 'return 2;', 'label': 0}
{'comment': '//decide whether to copy the existing arg set, or //build a new one from the list of all args excluding the special //operations that only we handle', 'code': 'reachedEof = true;', 'label': 0}
{'comment': '// type', 'code': 'if (argList.size() == args.length) {', 'label': 0}
{'comment': '// wait for TIME_OUT/2, there should be about TIME_OUT/2 ms remaining before timeout', 'code': 'String oldValue = (String) props.get(key);', 'label': 0}
{'comment': '"/*                fragments.addElement(value.substring(pos + 1, pos + 2));                prev = pos + 2;                */"', 'code': 'thread.join(TIME_OUT/2);', 'label': 0}
{'comment': '// Well, no matching constructor.', 'code': "if (value.charAt(pos + 1) == '$') {", 'label': 0}
{'comment': '//check that dir and src are incompatible', 'code': 'return null;', 'label': 0}
{'comment': '// OK, try without.', 'code': 'f.setSrc(new File("example.zip"));', 'label': 0}
{'comment': '// Set up a VSSHistory task', 'code': 'try {', 'label': 0}
{'comment': '// -ptime', 'code': 'MSVSSHISTORY vssHistory = new MSVSSHISTORY();', 'label': 0}
{'comment': '// Throws EjbcException if unsuccessful', 'code': 'cmd.createArgument().setValue(FLAG_PRESERVETIME);', 'label': 0}
{'comment': '// tests one the file object', 'code': 'EjbInfo[] ejbs = getEjbs(); // Returns list of EJBs for processing', 'label': 0}
{'comment': "// Make a limited attempt to extract a sanitized name and email address // Algorithm based on the one found in Ant's MailMessage.java", 'code': 'assertTrue("No index.html present. Not generated?", reportFile.exists() );', 'label': 0}
{'comment': '// if at eolcount == 0 and trailing characters of string // are CTRL-Zs, set eofStr', 'code': 'public EmailAddress(String email) {', 'label': 0}
{'comment': '// We have extra elements', 'code': 'if (eolcount == 0) {', 'label': 0}
{'comment': '// -keep', 'code': 'fail("extra args");', 'label': 0}
{'comment': '// keep searching for the first ^Z', 'code': 'cmd.createArgument().setValue(FLAG_KEEPCOPY);', 'label': 0}
{'comment': '// -identical', 'code': '}', 'label': 0}
{'comment': '// conversion to URL via FileUtils like in XMLResultAggregator, not as suggested in the bug report', 'code': 'cmd.createArgument().setValue(FLAG_IDENTICAL);', 'label': 0}
{'comment': '// Trailing characters are ^Zs // Construct new line and eofStr', 'code': 'URL reportUrl = new URL( FileUtils.getFileUtils().toURI(reportFile.getAbsolutePath()) );', 'label': 0}
{'comment': '// Check for required attributes', 'code': 'eofStr.append(line.toString().substring(i + 1));', 'label': 0}
{'comment': '// DO NOTHING', 'code': 'if (getTypeName() == null) {', 'label': 0}
{'comment': '// permissible values for compression attribute', 'code': '}', 'label': 0}
{'comment': '// build the command line from what we got. the format is // cleartool mkattr [options...] [viewpath ...] // as specified in the CLEARTOOL help', 'code': '/**', 'label': 0}
{'comment': '// use COUNT as the default.  This mimics the old behavior, although // NONE might be a better option moving forward in the case of callable', 'code': 'return ExecuteUpdateResultCheckStyle.COUNT;', 'label': 1}
{'comment': '//perhaps not really necessary...', 'code': 'String sequentialSelect = generateSequentialSelect(loadable);', 'label': 1}
{'comment': '// todo : what else to do here?', 'code': 'return null;', 'label': 1}
{'comment': '//TODO: disable batch loading if lockMode > READ?', 'code': 'return BatchingEntityLoaderBuilder.getBuilder( getFactory() )', 'label': 1}
{'comment': '// turn hibernate.c3p0.* into c3p0.*, so c3p0 // gets a chance to see all hibernate.c3p0.*', 'code': 'for ( Object o : props.keySet() ) {', 'label': 1}
{'comment': "// todo: this was added to support initializing an entity's EntityEntry snapshot during reattach; // this should be refactored to instead expose a method to assemble a EntityEntry based on this // state for return.", 'code': 'public Serializable[] getDisassembledState();', 'label': 1}
{'comment': '// Do we need to drop constraints before dropping tables in this dialect?', 'code': 'return true;', 'label': 1}
{'comment': '"/**     * FIXME Per the RegionFactory class Javadoc, this constructor version     * should not be necessary.     *      * @param props The configuration properties     */"', 'code': '*           Environmental properties; currently unused.', 'label': 1}
{'comment': '// Does this dialect support check constraints?', 'code': 'return false;', 'label': 1}
{'comment': "// this is done here 'cos we might only know the type here (ugly!) // TODO: improve this a lot:", 'code': 'if ( value instanceof ToOne ) {', 'label': 1}
{'comment': '// Does this dialect support the FOR UPDATE syntax?', 'code': 'return false;', 'label': 1}
{'comment': '// todo : what is the implication of this?', 'code': 'id.setDynamic( !entity.hasPojoRepresentation() );', 'label': 1}
{'comment': '// todo : YUCK!!!', 'code': 'optimizer = Environment.getBytecodeProvider().getReflectionOptimizer( mappedClass, getterNames, setterNames, propTypes );', 'label': 1}
{'comment': '// todo : again, how *should* this work for non-pojo entities?', 'code': 'if ( component.getOwner().hasPojoRepresentation() ) {', 'label': 1}
{'comment': '// Does this dialect support FOR UPDATE OF, allowing particular rows to be locked?', 'code': 'return false;', 'label': 1}
{'comment': '//TODO: really bad, evil hack to fix!!!', 'code': 'mappings.addSecondPass( new ManyToOneSecondPass(manyToOne) );', 'label': 1}
{'comment': '//aliasRefNode.resolve( false, false, aliasRefNode.getText() ); //TODO: is it kosher to do it here? //TODO: is it kosher to do it here?', 'code': 'aliasRefNode.resolve( false, false ); //TODO: is it kosher to do it here?', 'label': 1}
{'comment': '//TODO: better to degrade to lazy="false" if uninstrumented', 'code': '}', 'label': 1}
{'comment': '// Does this dialect support the Oracle-style FOR UPDATE NOWAIT syntax?', 'code': 'return false;', 'label': 1}
{'comment': '//Icky workaround for MySQL bug:', 'code': '!( dialect instanceof MySQLDialect ) ||', 'label': 1}
{'comment': '// we have to set up the table later!! yuck', 'code': '}', 'label': 1}
{'comment': '//TODO: Somehow add the newly created foreign keys to the internal collection', 'code': 'LOG.debug( "Creating tables\' unique integer identifiers" );', 'label': 1}
{'comment': '// This inner class implements a case statement....perhaps im being a bit over-clever here', 'code': 'abstract static class CollectionType {', 'label': 1}
{'comment': '//TODO: merge into one method!', 'code': 'cascadeBeforeSave(source, persister, entity, createCache);', 'label': 1}
{'comment': '// TODO: this is a bit of copy/paste from IndexedCollection.createPrimaryKey()', 'code': 'boolean indexIsFormula = false;', 'label': 1}
{'comment': '//TODO: inefficient', 'code': 'CacheEntry ce = persister.buildCacheEntry( instance,state, nextVersion, getSession() );', 'label': 1}
{'comment': '//FIXME: get the PersistentClass', 'code': 'java.util.Map propertyResults = bindPropertyResults(alias, returnElem, null, mappings );', 'label': 1}
{'comment': '//TODO: this is too conservative; if all preceding joins were  //      also inner joins, we could use an inner join here', 'code': '// IMPL NOTE : currentDepth might be less-than zero if this is the', 'label': 1}
{'comment': '//TODO: redesign how PropertyAccessors are acquired...', 'code': 'Property property = (Property) itr.next();', 'label': 1}
{'comment': '// TODO : not so sure this is needed...', 'code': 'throw new QueryException( "duplicate association path: " + wholeAssociationPath );', 'label': 1}
{'comment': '//create an index on the key columns??', 'code': '}', 'label': 1}
{'comment': '"/* TODO: joinKeyColumnName & foreignKeyColumnName should be called either here or at a\t\t\t * slightly higer level in the stack (to get all the information we need)\t\t\t * Right now HbmBinder does not support the\t\t\t */"', 'code': '* Right now HbmMetadataSourceProcessorImpl does not support the', 'label': 1}
{'comment': '//ick!', 'code': '}', 'label': 1}
{'comment': '// TODO: this is very suboptimal for some subclasses (namely components), // since it does not take advantage of two-phase-load', 'code': 'return nullSafeGet(rs, names, session, owner);', 'label': 1}
{'comment': '//TODO: should this be Session.instantiate(Persister, ...)?', 'code': 'copyCache.put( original, copy );', 'label': 1}
{'comment': '//TODO: suck this into initLaziness!', 'code': 'if ( "extra".equals( node.attributeValue("lazy") ) ) {', 'label': 1}
{'comment': '//TODO: is this right??', 'code': '}', 'label': 1}
{'comment': '//ie. the subquery! yuck!', 'code': '}', 'label': 1}
{'comment': '//use of a stringbuffer to workaround a JDK bug', 'code': 'return new StringBuffer( ownerEntityTable ).append( "_" )', 'label': 1}
{'comment': '//TODO: copy/paste from recreate()', 'code': 'offset = writeKey( st, id, offset, session );', 'label': 1}
{'comment': '//workaround, for backward compatibility of sets with no //not-null columns, assume all columns are used in the //row locator SQL', 'code': 'if ( !hasNotNullableColumns ) {', 'label': 1}
{'comment': '// todo : this eventually needs to be removed', 'code': 'public static PropertyAccessor getPropertyAccessor(Class optionalClass, String type) throws MappingException {', 'label': 1}
{'comment': '// todo : remove', 'code': 'public Getter getGetter(Class clazz) throws PropertyNotFoundException, MappingException {', 'label': 1}
{'comment': '//just to help out during the load (ugly, i know)', 'code': 'private transient Class elementClass;', 'label': 1}
{'comment': '// hack/workaround as sqlquery impl depend on having a key.', 'code': '}', 'label': 1}
{'comment': '//TODO: handle the case of a foreign key to something other than the pk', 'code': 'createForeignKeyOfEntity( ( (EntityType) getType() ).getAssociatedEntityName() );', 'label': 1}
{'comment': '//TODO: assumes all collections disassemble to an array!', 'code': 'return (Serializable[]) state;', 'label': 1}
{'comment': '//TODO: deprecated, remove eventually', 'code': ') {', 'label': 1}
{'comment': '//TODO possibly relax that', 'code': 'throw new DuplicateMappingException(', 'label': 1}
{'comment': '// TODO : this is a bit dodgy, come up with a better way to check this (plus see above comment)', 'code': 'String [] idColNames = owner.getQueryable().getIdentifierColumnNames();', 'label': 1}
{'comment': '//use a degenerated strategy for backward compatibility', 'code': 'return StringHelper.unqualify(propertyName);', 'label': 1}
{'comment': '//TODO: this is temporary in that the end result will probably not take a Property reference per-se.', 'code': 'if ( null == mode || EntityMode.POJO.equals( mode ) ) {', 'label': 1}
{'comment': "// todo : better to handle dynamic filters through implicit DynamicFilterParameterSpecification // see the discussion there in DynamicFilterParameterSpecification's javadocs as to why // it is currently not done that way.", 'code': 'int filteredParamCount = queryParameters.getFilteredPositionalParameterTypes() == null', 'label': 1}
{'comment': '// TODO: should "record" how many properties we have reffered to - and if we  //       don\'t get\'em\'all we throw an exception! Way better than trial and error ;)', 'code': 'private String substituteBrackets(String sqlQuery) throws QueryException {', 'label': 1}
{'comment': '//TODO: this dependency is kinda Bad', 'code': 'private static final PropertyAccessor BASIC_PROPERTY_ACCESSOR = new BasicPropertyAccessor();', 'label': 1}
{'comment': '//TODO: get SQL rendering out of this package!', 'code': '}', 'label': 1}
{'comment': '// why does this matter?', 'code': 'if ( oj.getJoinable().isCollection() ) {', 'label': 1}
{'comment': '// important, to account for newly saved entities in query // todo : some kind of check for new status...', 'code': 'LOG.trace( "Owning entity already loaded; ignoring" );', 'label': 1}
{'comment': '//TODO: can we *always* use the "null property" approach for everything?', 'code': '/*if ( isPrimaryKey && !isSpecialOneToOne ) {', 'label': 1}
{'comment': '// todo : remove this and just have subclasses use Isolater/IsolatedWork directly...', 'code': 'public Getter getGetter(Class clazz) throws PropertyNotFoundException, MappingException {', 'label': 1}
{'comment': '// sql-server, at least needed this dropped after use; strange!', 'code': '}', 'label': 1}
{'comment': '// is it necessary to register %exact since it can only appear in a where clause?', 'code': 'registerFunction( "%exact", new StandardSQLFunction( "%exact", StandardBasicTypes.STRING ) );', 'label': 1}
{'comment': '// Does this dialect support the ALTER TABLE syntax?', 'code': 'return true;', 'label': 1}
{'comment': '// This next bit is to allow for both unsaved-value="negative" // and for "older" behavior where version number did not get // seeded if it was already set in the object // TODO: shift it into unsaved-value strategy', 'code': '( (initialVersion instanceof Number) && ( (Number) initialVersion ).longValue()<0 )', 'label': 1}
{'comment': '//TODO: reenable if we also fix the above todo', 'code': '/*EntityPersister persister = getEntityPersister();', 'label': 1}
{'comment': '// orphans should not be deleted during merge??', 'code': 'return false;', 'label': 1}
{'comment': '//TODO: suck this logic into the collection!', 'code': 'final Collection orphans;', 'label': 1}
{'comment': '// todo : we can actually just determine this from the incoming EntityEntry-s', 'code': 'rtn.hasNonReadOnlyEntities = ois.readBoolean();', 'label': 1}
{'comment': "//TODO: this bit actually has to be called after all cascades! //      but since identity insert is called *synchronously*, //      instead of asynchronously as other actions, it isn't", 'code': '/*if ( persister.hasCache() && !persister.isCacheInvalidationRequired() ) {', 'label': 1}
{'comment': '// this class has no proxies (so do a shortcut)', 'code': 'if (!persister.hasProxy()) {', 'label': 1}
{'comment': '// todo : need map? the prob is a proper key, right?', 'code': 'public EntityLoadContext(LoadContexts loadContexts, ResultSet resultSet) {', 'label': 1}
{'comment': '//TODO: better to pass the id in as an argument?', 'code': 'if (LOG.isDebugEnabled()) {', 'label': 1}
{'comment': '//do we even really need this? the update will fail anyway....', 'code': 'if ( session.getFactory().getStatistics().isStatisticsEnabled() ) {', 'label': 1}
{'comment': '//TODO: would it be better to do a refresh from db?', 'code': '}', 'label': 1}
{'comment': '//TODO: ugly here:', 'code': 'final String queryString = queryParameters.getFilteredSQL();', 'label': 1}
{'comment': '//TODO: not quite sure about the full implications of this!', 'code': 'addExtraJoins( joinFragment, rootAlias, rootJoinable, true );', 'label': 1}
{'comment': "// todo : i'd much rather have this done from #endLoadingCollection(CollectionPersister,LoadingCollectionEntry)...", 'code': 'loadContexts.unregisterLoadingCollectionXRef( collectionKey );', 'label': 1}
{'comment': '//PostLoad is needed for EJB3 //TODO: reuse the PostLoadEvent...', 'code': 'PostLoadEvent postLoadEvent = new PostLoadEvent( session )', 'label': 1}
{'comment': '// todo : should we check the current isolation mode explicitly?', 'code': 'Object nextVersion = persister.forceVersionIncrement(', 'label': 1}
{'comment': "// brand new collection //TODO: or an array!! we can't lock objects with arrays now??", 'code': 'throw new HibernateException( "reassociated object has dirty collection reference (or an array)" );', 'label': 1}
{'comment': "// null or brand new collection // this will also (inefficiently) handle arrays, which have // no snapshot, so we can't do any better", 'code': 'removeCollection(persister, collectionKey, session);', 'label': 1}
{'comment': '// TODO : perhaps we should additionally require that the incoming entity // version be equivalent to the defined unsaved-value?', 'code': 'return changed && existsInDatabase( target, source, persister );', 'label': 1}
{'comment': '"/** * Provides query splitting methods, which were originally in QueryTranslator. * <br> * TODO: This will need to be refactored at some point. * * @author josh */"', 'code': 'public final class NameGenerator {', 'label': 1}
{'comment': '// TODO : most of below was taken verbatim from DotNode; should either delegate this logic or super-type it', 'code': 'CollectionType type = (CollectionType) getDataType();', 'label': 1}
{'comment': '// TODO : better way?!?', 'code': '( ( DotNode ) dot ).setPropertyPath( ( ( FromReferenceNode ) property ).getPath() );', 'label': 1}
{'comment': '// Not possible to simply re-use the versionPropertyNode here as it causes // OOM errors due to circularity :(', 'code': 'versionIncrementNode = getASTFactory().create( HqlSqlTokenTypes.PLUS, "+" );', 'label': 1}
{'comment': '//TODO:this is only needed during compilation .. can we eliminate the instvar?', 'code': 'private boolean compiled;', 'label': 1}
{'comment': '//TODO: is this a bit ugly?', 'code': 'expr.setText( text );', 'label': 1}
{'comment': '//TODO: switch statements are always evil! We already had bugs because  //      of forgotten token types. Use polymorphism for this!', 'code': 'switch ( x.getType() ) {', 'label': 1}
{'comment': '//TODO: used to be exprNoParens! was this needed?', 'code': '}', 'label': 1}
{'comment': "// TODO : we may also want to check that the types here map to exactly one column/JDBC-type //      can't think of a situation where arithmetic expression between multi-column mappings //      makes any sense.", 'code': 'Node lhs = getLeftHandOperand();', 'label': 1}
{'comment': '// we do not know either type //BLIND GUESS!', 'code': 'return StandardBasicTypes.DOUBLE; //BLIND GUESS!', 'label': 1}
{'comment': '// TODO: get SQL rendering out of here, create an AST for the join expressions. // Use the SQL generator grammar to generate the SQL text for the index expression.', 'code': 'JoinSequence joinSequence = fromElement.getJoinSequence();', 'label': 1}
{'comment': '// not absolutely necessary, but does help with aggressive release', 'code': '//session.getJDBCContext().getConnectionManager().closeQueryStatement( ps, resultSet );', 'label': 1}
{'comment': '//TODO: this is one of the ugliest and most fragile pieces of code in Hibernate....', 'code': 'String[] tokens = StringHelper.split( StringHelper.WHITESPACE + "(),", query, true );', 'label': 1}
{'comment': '//yuck!', 'code': 'Fo fo = Fo.newFo( (FumCompositeID) id );', 'label': 1}
{'comment': '// ignore it; the incoming property could not be found so we // cannot be sure what to do here.  At the very least, the // safest is to simply not apply any dereference toggling...', 'code': 'public boolean isDereferencedBySuperclassProperty() {', 'label': 1}
{'comment': '// yuck!', 'code': 'Fo fo = Fo.newFo( (FumCompositeID) id );', 'label': 1}
{'comment': '// todo : potentially look at optimizing these two arrays', 'code': 'oos.writeObject( loadedState );', 'label': 1}
{'comment': '//note that i parameter is now unused (delete it?)', 'code': '/**', 'label': 1}
{'comment': '// TODO: Figure out a better way to get the FROM elements in a proper tree structure. // If this is not the destination of a many-to-many, add it as a child of the origin.', 'code': 'if ( manyToMany ) {', 'label': 1}
{'comment': '// TODO : this constructor form is *only* used from constructor directly below us; can it go away?', 'code': 'super( sql, flushMode, session, parameterMetadata );', 'label': 1}
{'comment': '// We should reengineer this class so that, rather than the current ad - // hoc linear approach to processing a stream of tokens, we instead // build up a tree of expressions.', 'code': '// We would probably refactor to have LogicParser (builds a tree of simple', 'label': 1}
{'comment': '// todo : should this get moved to PersistentContext? // logically, is PersistentContext the "thing" to which an interceptor gets attached?', 'code': 'final Object result = persistenceContext.getEntity(key);', 'label': 1}
{'comment': '// TODO: something much better - look at the type of the other expression! // TODO: Have comparisonExpression and/or arithmeticExpression rules complete the resolution of boolean nodes.', 'code': 'String replacement = ( String ) walker.getTokenReplacements().get( constant.getText() );', 'label': 1}
{'comment': '//TODO: this class does too many things! we need a different //kind of path expression parser for each of the diffferent //ways in which path expressions can occur', 'code': '//We should actually rework this class to not implement Parser', 'label': 1}
{'comment': '//TODO: optimize this better!', 'code': 'return index==-1 ? 0 : getSubclassPropertyTableNumber(index);', 'label': 1}
{'comment': '//TODO: should we allow suffixes on these ?', 'code': 'return ( String[] ) subclassPropertyColumnNames.get( propertyName );', 'label': 1}
{'comment': '//TODO: is this really necessary????', 'code': 'boolean[] includeOldField = entityMetamodel.getOptimisticLockStyle() == OptimisticLockStyle.ALL', 'label': 1}
{'comment': '// TODO : not sure the best way to handle this. // The non-performant way :', 'code': 'last();', 'label': 1}
{'comment': '//TODO: is there a better way?', 'code': 'return collectionName != null && !getPropertyType().isCollectionType();', 'label': 1}
{'comment': '//The class is now way to complex!', 'code': 'private int dotcount;', 'label': 1}
{'comment': '// TODO : would be really nice to cache the spec on the query-def so as to not have to re-calc the hash; // currently not doable though because of the resultset-ref stuff...', 'code': 'NativeSQLQuerySpecification spec;', 'label': 1}
{'comment': '//name from a super query (a bit inelegant that it shows up here)', 'code': '}', 'label': 1}
{'comment': '//put() has nowait semantics, is this really appropriate? //note that it needs to be async replication, never local or sync', 'code': 'region.put( space, ts );', 'label': 1}
{'comment': '// ugly hack for cases like "elements(foo.bar.collection)" // (multi-part path expression ending in elements or indices)', 'code': 'String[] tokens = StringHelper.split( ".", token, true );', 'label': 1}
{'comment': '//TODO: COPY/PASTE FROM SessionImpl, pull up!', 'code': '@Override', 'label': 1}
{'comment': '//Must be done here because of side-effect! yuck...', 'code': 'int scalarSize = scalarTypes.size();', 'label': 1}
{'comment': '//We should actually rework this class to not implement Parser //and just process path expressions in the most convenient way.', 'code': '//The class is now way to complex!', 'label': 1}
{'comment': '// we may be screwed here since the collection action is about to execute // and we do not know the final owner key value', 'code': 'return finalKey;', 'label': 1}
{'comment': '// Needed the "clazz_" check to work around union-subclasses // TODO : is there a way to tell whether a persister is truly discrim-column based inheritence?', 'code': 'if ( discrimColumnName != null && !"clazz_".equals( discrimColumnName ) ) {', 'label': 1}
{'comment': '//TODO: reuse the PreLoadEvent', 'code': 'final PreLoadEvent preLoadEvent = new PreLoadEvent( session )', 'label': 1}
{'comment': '// Need a better way to define the suffixes here...', 'code': 'text = child.renderValueCollectionSelectFragment( nonscalarSize, nonscalarSize + k );', 'label': 1}
{'comment': '//workaround for WebLogic', 'code': 'LOG.debug("could not log warnings", sqle);', 'label': 1}
{'comment': '//TODO: temporary', 'code': 'final ComponentMetamodel metamodel = new ComponentMetamodel( this );', 'label': 1}
{'comment': '// TODO : YUCK!!!  fix after HHH-1907 is complete', 'code': 'return Environment.getBytecodeProvider().getProxyFactoryFactory().buildProxyFactory();', 'label': 1}
{'comment': '// some messy, complex stuff here, since createCriteria() can take an // aliased path, or a path rooted at the creating criteria instance', 'code': 'Criteria parent = null;', 'label': 1}
{'comment': '//TODO: add a CriteriaImplementor interface //      this class depends directly upon CriteriaImpl in the impl package...', 'code': 'private final CriteriaQueryTranslator translator;', 'label': 1}
{'comment': '// polymorphism not really handled completely correctly, // perhaps...well, actually its ok, assuming that the // entity name used in the lookup is the same as the // the one used here, which it will be', 'code': 'EntityUniqueKey euk = new EntityUniqueKey(', 'label': 1}
{'comment': '//This is not very nice (and quite slow):', 'code': 'final String[][] cols = persister == rootPersister ?', 'label': 1}
{'comment': '//TODO: get SQL rendering out of here', 'code': 'CollectionElement elem = new CollectionElement();', 'label': 1}
{'comment': '// meant to handle dynamic instantiation queries...(Copy from QueryLoader)', 'code': 'HolderInstantiator holderInstantiator = buildHolderInstantiator( resultTransformer );', 'label': 1}
{'comment': '// Make sure this is a defined parameter and check the incoming value type // TODO: what should be the actual exception type here?', 'code': 'Type type = definition.getParameterType( name );', 'label': 1}
{'comment': '// worrying about proxies is perhaps a little bit of overkill here...', 'code': 'if ( element instanceof HibernateProxy ) {', 'label': 1}
{'comment': '// todo : throw exception?  maybe warn if not the same?', 'code': '}', 'label': 1}
{'comment': '//TODO: make EntityPersister *not* depend on SessionFactoryImplementor //interface, if possible', 'code': '//NOTE: unlike all other Loaders, this one is NOT', 'label': 1}
{'comment': '// TODO : what amount of significant digits need to be supported here? //      - from the DecimalFormat docs: //          [significant digits] = [minimum integer digits] + [maximum fraction digits]', 'code': 'DecimalFormat jdkFormatter = new DecimalFormat( FORMAT_STRING );', 'label': 1}
{'comment': '//for backward compatibility, allow a set with no not-null  //element columns, using all columns in the row locater SQL //TODO: create an implicit not null constraint on all cols?', 'code': 'else {', 'label': 1}
{'comment': '// TODO: copy/paste from ManyToOneType', 'code': 'public Serializable disassemble(Object value, SessionImplementor session, Object owner)', 'label': 1}
{'comment': '//TODO: code duplication with SingleTableEntityPersister', 'code': 'ArrayList columnTableNumbers = new ArrayList();', 'label': 1}
{'comment': '// todo : throw exception?', 'code': '}', 'label': 1}
{'comment': '//should this interface extend PropertyMapping?', 'code': '/**', 'label': 1}
{'comment': '// TODO: here is why we need to make bytecode provider global :( // TODO : again, fix this after HHH-1907 is complete', 'code': 'optimizer = Environment.getBytecodeProvider().getReflectionOptimizer(', 'label': 1}
{'comment': '//TODO: currently keeps Getters and Setters (instead of PropertyAccessors) because of the way getGetter() and getSetter() are implemented currently; yuck!', 'code': 'private final EntityMetamodel entityMetamodel;', 'label': 1}
{'comment': "//TODO: Yuck! This is not quite good enough, it's a quick //hack around the problem of having a to-one association //that refers to an embedded component:", 'code': 'super.getReturnedClass().isInstance(parent);', 'label': 1}
{'comment': '//TODO: implement caching?! proxies?!', 'code': 'EntityUniqueKey euk = new EntityUniqueKey(', 'label': 1}
{'comment': '// is this really necessary?', 'code': 'ByteArrayOutputStream outputStream = new ByteArrayOutputStream(2048);', 'label': 1}
{'comment': "//TODO: this is a little inefficient, don't need to do a whole //      deep replaceElements() call", 'code': 'replaceElements( result, target, owner, copyCache, session );', 'label': 1}
{'comment': '//TODO: this is a bit arbitrary, expose a switch to the user?', 'code': 'return "";', 'label': 1}
{'comment': '"/**\t * @return collection removal\t * FIXME: even if isInverse=""true""?\t */"', 'code': '*         FIXME: even if isInverse="true"?', 'label': 1}
{'comment': '// TODO: Fix this so it will work for non-POJO entity mode', 'code': 'Type keyType = getPersister( session ).getKeyType();', 'label': 1}
{'comment': '//TODO: move these to a new JoinableType abstract class, //extended by EntityType and PersistentCollectionType:', 'code': '* Is the primary key of the owning entity table', 'label': 1}
{'comment': "//SPACES //TODO: i'm not sure, but perhaps we should exclude //      abstract denormalized tables?", 'code': 'int spacesSize = 1 + persistentClass.getSynchronizedTables().size();', 'label': 1}
{'comment': '//TODO: is there a more elegant way than downcasting?', 'code': 'AbstractQueryImpl query = (AbstractQueryImpl) session.getNamedSQLQuery(queryName);', 'label': 1}
{'comment': '//TODO: remove use of instanceof!', 'code': 'Component component = (Component) prop.getValue();', 'label': 1}
{'comment': '//TODO: perhaps this should be some other RuntimeException...', 'code': 'throw new HibernateException( "illegally attempted to associate a proxy with two open Sessions" );', 'label': 1}
{'comment': '//Yuck:', 'code': 'if ( inFromClause', 'label': 1}
{'comment': '//TODO: design new lifecycle for ProxyFactory', 'code': 'pf.postInstantiate(', 'label': 1}
{'comment': '// todo: we should really just collect these from the various SelectExpressions, rather than regenerating here', 'code': 'columnNames = getSessionFactoryHelper().generateColumnNames( queryReturnTypes );', 'label': 1}
{'comment': '// TODO: Should this really return null?  If not, figure out something better to do here.', 'code': '}', 'label': 1}
{'comment': '// TODO : this really needs to be delayed unitl after we definitively know all node types // where this is currently a problem is parameters for which where we cannot unequivocally // resolve an expected type', 'code': 'SessionFactoryImplementor sessionFactory = getSessionFactoryHelper().getFactory();', 'label': 1}
{'comment': '// create an index on the key columns??', 'code': '}', 'label': 1}
{'comment': '//init the table here instead of earlier, so that we can get a quoted table name //TODO: would it be better to simply pass the qualified table name, instead of //      splitting it up into schema/catalog/table names', 'code': 'String tableName = getTable().getQuotedName(dialect);', 'label': 1}
{'comment': '// NOTE: this assumes something about how propertySelectFragment is implemented by the subclass! // was toUnqotedAliasStrings( getdiscriminatorColumnName() ) before - now tried // to remove that unqoting and missing aliases..', 'code': '// was toUnqotedAliasStrings( getIdentiferColumnNames() ) before - now tried', 'label': 1}
{'comment': "// Put a placeholder in entries, so we don't recurse back and try to save() the // same object again. QUESTION: should this be done before onSave() is called? // likewise, should it be done before onUpdate()?", 'code': 'source.getPersistenceContext().addEntry(', 'label': 1}
{'comment': '//before cascade! //TODO: should this be Session.instantiate(Persister, ...)?', 'code': 'copyCache.put( original, copy );', 'label': 1}
{'comment': '//TODO: we should throw an exception if we really *know* for sure   //      that this is a detached instance, rather than just assuming //throw new StaleObjectStateException(entityName, id);', 'code': 'propertyName', 'label': 1}
{'comment': '//TODO: if object was an uninitialized proxy, this is inefficient, //      resulting in two SQL selects', 'code': 'EntityEntry entry = source.getPersistenceContext().getEntry(entity);', 'label': 1}
{'comment': '//TODO: put this stuff back in to read snapshot from //      the second-level cache (needs some extra work)', 'code': '/*Object[] cachedState = null;', 'label': 1}
{'comment': '//this is kinda the best we can do...', 'code': 'if ( object instanceof HibernateProxy ) {', 'label': 1}
{'comment': '/* trim done to workaround stupid oracle bug that cant handle whitespaces before a { in a sp */', 'code': 'cacheable,', 'label': 1}
{'comment': "//TODO: this needn't exclude subclasses...", 'code': 'LinkedHashSet<EntityKey> set =  batchLoadableEntityKeys.get( persister.getEntityName() );', 'label': 1}
{'comment': '//TODO: we use two visitors here, inefficient!', 'code': 'OnReplicateVisitor visitor = new OnReplicateVisitor( source, id, entity, false );', 'label': 1}
{'comment': "//TODO: does this really need to be here? //      does the collection already have //      it's own up-to-date snapshot?", 'code': 'return collection.wasInitialized() &&', 'label': 1}
{'comment': "// TODO: an alternative is to check if the owner has changed; if it hasn't then // return collection.getOwner()", 'code': 'Serializable entityId = getLoadedCollectionOwnerIdOrNull( ce );', 'label': 1}
{'comment': '//I suppose?', 'code': '}', 'label': 1}
{'comment': '"// TBD should this be varbinary($1)? //\t\tregisterColumnType(Types.VARBINARY,     ""binary($1)"");"', 'code': '//\t\tregisterColumnType(Types.VARBINARY,     "binary($1)");', 'label': 1}
{'comment': '//shortcut', 'code': '}', 'label': 1}
{'comment': '// todo : should we additionally check the current isolation mode explicitly?', 'code': 'SessionFactoryImplementor factory = session.getFactory();', 'label': 1}
{'comment': '// todo : is there really any reason to kkeep trying if this fails once?', 'code': 'oracleCursorTypeSqlType = extractOracleCursorTypeValue();', 'label': 1}
{'comment': '// TODO : not sure this is correct, could not find docs on how to do this.', 'code': 'return "{?= call current_timestamp}";', 'label': 1}
{'comment': '//HSQL has no Blob/Clob support .... but just put these here for now!', 'code': 'if ( hsqldbVersion < 20 ) {', 'label': 1}
{'comment': '"// merges don\'t cascade to uninitialized collections //\t\t\t//TODO: perhaps this does need to cascade after all...."', 'code': 'return getLoadedElementsIterator(session, collectionType, collection);', 'label': 1}
{'comment': '// yick!  need this for proper serialization/deserialization handling...', 'code': 'wrapper.setWrapped( wrapped );', 'label': 1}
{'comment': '//TODO: should orphans really be deleted during lock???', 'code': 'return false;', 'label': 1}
{'comment': '// todo : move to StringHelper?', 'code': 'if ( stringForm != null ) {', 'label': 1}
{'comment': "// Sets can be just a view of a part of another collection. // do we need to copy it to be sure it won't be changing // underneath us? // ie. this.set.addAll(set);", 'code': 'this.set = set;', 'label': 1}
{'comment': '// TODO: It would be really, really nice to use this to also model components!', 'code': '/**', 'label': 1}
{'comment': '//TODO: move to .sql package!!', 'code': 'buf.append("select ");', 'label': 1}
{'comment': "//TODO: look at the owning property and check that it  //      isn't lazy (by instrumentation)", 'code': 'EntityType entityType =(EntityType) type;', 'label': 1}
{'comment': '// TODO : add this info to the translator and aggregate it here...', 'code': 'return null;', 'label': 1}
{'comment': '// would be better to use the element-type to determine // whether the old and the new are equal here; the problem being // we do not necessarily have access to the element type in all // cases', 'code': 'if ( value != old ) {', 'label': 1}
{'comment': '//TODO: code duplication with JoinedSubclassEntityPersister', 'code': 'ArrayList columnJoinNumbers = new ArrayList();', 'label': 1}
{'comment': '//TODO: refactor to .sql package', 'code': 'private CollectionSubqueryFactory() {', 'label': 1}
{'comment': '//TODO: *two* hashmap lookups here is one too many...', 'code': 'String[] columns = (String[]) columnsByPropertyPath.get(propertyName);', 'label': 1}
{'comment': '//note that this method could easily be moved up to BasicEntityPersister, //if we ever needed to reuse it from other subclasses', 'code': '//figure out which tables need to be fetched', 'label': 1}
{'comment': '// from the collection of associations, locate OJA for the // ManyToOne corresponding to this persister to fully // define the many-to-many; we need that OJA so that we can // use its alias here // TODO : is there a better way here?', 'code': 'Iterator itr = associations.iterator();', 'label': 1}
{'comment': '//TODO: this class depends directly upon CriteriaImpl,  //      in the impl package ... add a CriteriaImplementor  //      interface', 'code': '//NOTE: unlike all other Loaders, this one is NOT', 'label': 1}
{'comment': '// Do we need to qualify index names with the schema name?', 'code': 'return false;', 'label': 1}
{'comment': '//TODO: We probably should have a StatisticsNotPublishedException, to make it clean', 'code': 'SessionFactory sf;', 'label': 1}
{'comment': '// NOTE VERY HACKISH WORKAROUND!! // TODO: Fix this so it will work for non-POJO entity mode', 'code': 'Type keyType = getPersister( session ).getKeyType();', 'label': 1}
{'comment': '//TODO: need to make the majority of this functionality into a top-level support class for custom impl support', 'code': '/**', 'label': 1}
{'comment': '//TODO: inefficient if that cache is just going to ignore the updated state!', 'code': 'CacheEntry ce = persister.buildCacheEntry( instance,state, nextVersion, getSession() );', 'label': 1}
{'comment': "// TODO: an alternative is to check if the owner has changed; if it hasn't then // get the ID from collection.getOwner()", 'code': '// return collection.getOwner()', 'label': 1}
{'comment': '//TODO:refactor + make this method private', 'code': 'arrayHolders.put( holder.getValue(), holder );', 'label': 1}
{'comment': '// todo : temporary //      needed because currently persister is the one that //      creates and renders the join fragments for inheritence //      hierarchies...', 'code': '// creates and renders the join fragments for inheritance', 'label': 1}
{'comment': '//swaldman 2004-02-07: modify to allow null values to signify fall through to c3p0 PoolConfig defaults', 'code': 'Integer minPoolSize = ConfigurationHelper.getInteger( Environment.C3P0_MIN_SIZE, props );', 'label': 1}
{'comment': '// work around that crazy issue where the tree contains // "empty" FromElements (no text); afaict, this is caused // by FromElementFactory.createCollectionJoin()', 'code': 'if ( fromElement.getOrigin() == null ) {', 'label': 1}
{'comment': '//TODO: move to .sql package, and refactor with similar things!', 'code': 'return StringHelper.join( "=? and ",', 'label': 1}
{'comment': '//TODO: I am not so sure about the exception handling in this bit!', 'code': 'sequentialSelect = session.getTransactionCoordinator()', 'label': 1}
{'comment': '//ugly little workaround for fact that createUniqueKeyLoaders() does not handle component properties', 'code': 'if ( useStaticLoader ) {', 'label': 1}
{'comment': '// append the SQL to return the generated identifier //TODO: suck into Insert', 'code': 'if ( j == 0 && identityInsert && useInsertSelectIdentity() ) { //TODO: suck into Insert', 'label': 1}
{'comment': '//This is really ugly, but necessary:', 'code': '/**', 'label': 1}
{'comment': '// todo : modify the class definition if not already transformed...', 'code': 'byte[] b = cc.toBytecode();', 'label': 1}
{'comment': '//TODO: should we use SELECT .. FOR UPDATE?', 'code': 'Select select = new Select( getFactory().getDialect() );', 'label': 1}
{'comment': '//TODO: is this 100% correct?', 'code': 'getSession().getPersistenceContext().getCollectionsByKey().remove(', 'label': 1}
{'comment': '// NOTE: this assumes something about how propertySelectFragment is implemented by the subclass! // was toUnqotedAliasStrings( getIdentiferColumnNames() ) before - now tried // to remove that unqoting and missing aliases..', 'code': 'return new Alias( suffix ).toAliasStrings( getIdentifierAliases() );', 'label': 1}
{'comment': '//TODO: move into collection type, so we can use polymorphism!', 'code': 'if ( collectionType.hasHolder() ) {', 'label': 1}
{'comment': '// TODO should we just collect these like with the collections above?', 'code': 'sqlAliasSuffixes[i] = ( size == 1 ) ? "" : Integer.toString( i ) + "_";', 'label': 1}
{'comment': '//hum ... should we cascade anyway? throw an exception? fine like it is?', 'code': 'return;', 'label': 1}
{'comment': '//TODO: copy/paste from insertRows()', 'code': 'int loc = writeKey( st, id, offset, session );', 'label': 1}
{'comment': '//TODO: suck into event class', 'code': '}', 'label': 1}
{'comment': '// xmlforest requires a new kind of function constructor', 'code': 'registerFunction( "year", new StandardJDBCEscapeFunction( "year", StandardBasicTypes.INTEGER ) );', 'label': 1}
{'comment': '// TODO Is this a valid operation on a timestamps cache?', 'code': 'Transaction tx = suspend();', 'label': 1}
{'comment': '//need to do that here rather than in the save event listener to let //the post insert events to have a id-filled entity when IDENTITY is used (EJB3)', 'code': 'persister.setIdentifier( instance, generatedId, session );', 'label': 1}
{'comment': '// TODO : safe to interpret "map.remove(key) == null" as non-dirty?', 'code': 'initialize( true );', 'label': 1}
{'comment': '// TODO: Replace this with a more elegant solution.', 'code': 'String[] idColumnNames = ( persister != null ) ?', 'label': 1}
{'comment': '// short cut check...', 'code': 'if ( !Character.isLetter( chars[0] ) ) {', 'label': 1}
{'comment': '// this is ugly here, but needed because its a subquery', 'code': 'q.addQuerySpaces( q.getCollectionPersister( pathExpressionParser.getCollectionRole() ).getCollectionSpaces() );', 'label': 1}
{'comment': '// TODO : will need reference to session factory to fully complete HHH-1907', 'code': '//\tprivate final SessionFactoryImplementor sessionFactory;', 'label': 1}
{'comment': '// inheritance cycle detection (paranoid check)', 'code': 'PersistentClass superclass = getSuperclass();', 'label': 1}
{'comment': '// TODO: encapsulate the protected instance variables!', 'code': 'private final String role;', 'label': 1}
{'comment': '//polymorphism comment above', 'code': 'ukName,', 'label': 1}
{'comment': '// TODO: handle TypeDefs', 'code': 'Attribute typeNode = node.attribute( "type" );', 'label': 1}
{'comment': '//TODO: get all properties, not just the fetched ones!', 'code': 'metadata.getServiceRegistry()', 'label': 1}
{'comment': '//TODO: native ids', 'code': 'Serializable id = persister.getIdentifierGenerator().generate( getSession(), entry );', 'label': 1}
{'comment': '// TODO: bindpropertyresults(alias, returnElem)', 'code': 'lockMode', 'label': 1}
{'comment': '//TODO: handle property-ref', 'code': 'return "? " +', 'label': 1}
{'comment': '//TODO: validate existing of property with the chosen name. (secondpass )', 'code': 'ArrayList allResultColumns = getResultColumns(propertyresult);', 'label': 1}
{'comment': '//TODO: check that entry.getIdentifier().equals(requestedId)', 'code': '.getColumnIterator() );', 'label': 1}
{'comment': '// TODO: RESTRICT VIOLATION', 'code': 'case 23001: return null;', 'label': 1}
{'comment': '//TODO: assertion only, could be optimized away', 'code': 'throw new AssertionFailure( "entity was persistent" );', 'label': 1}
{'comment': '//TODO: optimize away this lookup for entities w/o unsaved-value="undefined"', 'code': 'final EntityKey entityKey = session.generateEntityKey( id, persister );', 'label': 1}
{'comment': '//TODO: arithmetic expressions, multiple new Foo(...)', 'code': 'private static final Set COUNT_MODIFIERS = new HashSet();', 'label': 1}
{'comment': '// TODO: not visible to the user!', 'code': '}', 'label': 1}
{'comment': '//TODO: proxies!', 'code': 'if ( me.getValue()==element ) return me.getKey();', 'label': 1}
{'comment': '//TODO: can we limit stored procedures ?!', 'code': 'col += limitHandler.bindLimitParametersAtStartOfQuery( st, col );', 'label': 1}
{'comment': '//TODO: formulas ?', 'code': 'public void initCollectionPropertyMap() {', 'label': 1}
{'comment': '// TODO: better error message since we actually support composites if names are explicitly listed.', 'code': 'throw new QueryException(', 'label': 1}
{'comment': '//TODO: use these in methods above', 'code': 'public String getEntityName(Criteria subcriteria, String propertyName) {', 'label': 1}
{'comment': '//TODO: cache the persister, this shows up in yourkit', 'code': 'final Serializable id = session.getEntityPersister( entityName, obj ).getIdentifier( obj, session );', 'label': 1}
{'comment': '//TODO: add referencedClass to disambiguate to FKs on the same //      columns, pointing to different tables', 'code': 'fk.setTable( this );', 'label': 1}
{'comment': '//TODO: create uk loaders for component properties', 'code': '}', 'label': 1}
{'comment': '//TODO: terrible implementation!', 'code': 'return value == null', 'label': 1}
{'comment': '//TODO: eventually put this back in, once we think all is fixed //Object otherAlias = columnsUnique.put(qualifiedColumn, columnAlias);', 'code': '/*if ( otherAlias!=null && !columnAlias.equals(otherAlias) ) {', 'label': 1}
{'comment': "// TODO: I don't really like this implementation; it would be better if // this was handled by searchForDirtyCollections()", 'code': 'return isOwnerVersioned( session ) && super.isDirty( old, current, session );', 'label': 1}
{'comment': '// TODO: check if key contains the owner ID', 'code': '}', 'label': 1}
{'comment': '//TODO: cache this in an instvar', 'code': 'return getFactory().getDialect().getIdentitySelectString(', 'label': 1}
{'comment': '// TODO : temporary initial step towards HHH-1907', 'code': 'final ComponentMetamodel metamodel = new ComponentMetamodel( this );', 'label': 1}
{'comment': '// todo : remove this once ComponentMetamodel is complete and merged', 'code': 'public Getter getGetter(Class clazz) throws PropertyNotFoundException, MappingException {', 'label': 1}
{'comment': '//TODO: add owner argument!!', 'code': 'throws HibernateException;', 'label': 1}
{'comment': '//TODO: for some dialects it would be appropriate to add the renderOrderByPropertiesSelect() to other select strings', 'code': 'mergeJoins( sql.getJoinFragment() );', 'label': 1}
{'comment': '//TODO: unnecessary for databases with ANSI-style joins', 'code': 'DisjunctionFragment df = new DisjunctionFragment();', 'label': 1}
{'comment': '//TODO: maybe call it getRowSelection() ?', 'code': 'public RowSelection getSelection() {', 'label': 1}
{'comment': '//TODO: make this handle multiple collection roles!', 'code': 'final CollectionPersister[] collectionPersisters = getCollectionPersisters();', 'label': 1}
{'comment': '//TODO: include the rowids!!!!', 'code': 'if ( hasSubclasses() ) {', 'label': 1}
{'comment': "// TODO : or should we return 'containsTableAlias'??", 'code': 'LOG.tracev( "Forcing inclusion of extra joins [alias={0}, containsTableAlias={1}]", alias, containsTableAlias );', 'label': 1}
{'comment': '/////////////////////////////////////////////////////////////////////// // TODO : look at perhaps caching this...', 'code': '// as a control measure, now update the node while it is detached and', 'label': 1}
{'comment': '//TODO: avoid this for non-new instances where mightBeDirty==false', 'code': 'boolean substitute = wrapCollections( session, persister, types, values);', 'label': 1}
{'comment': '// todo : look at optimizing these...', 'code': 'oos.writeObject( loadQueryInfluencers );', 'label': 1}
{'comment': '// todo : cache this sql...', 'code': 'String versionIncrementString = generateVersionIncrementUpdateString();', 'label': 1}
{'comment': '"/**\t * TODO: Check if Mimer SQL cannot handle the way DB2 does\t */"', 'code': 'public boolean supportsIdentityColumns() {', 'label': 1}
{'comment': '//TODO: if we are using identity columns, fetch the identifier', 'code': '}', 'label': 1}
{'comment': '//TODO check there is no actual definition elemnents when a ref is defined', 'code': '}', 'label': 1}
{'comment': '// table=null -> an association // - fill it in later //TODO fill in the mappings for table == null', 'code': 'mappings.addColumnBinding( logicalColumnName, column, table );', 'label': 1}
{'comment': '// table=null -> an association - fill // it in later //TODO fill in the mappings for table == null', 'code': 'mappings.addColumnBinding( logicalColumnName, column, table );', 'label': 1}
{'comment': "// TODO : why aren't these the same?", 'code': 'if ( lhs.getImpliedJoin() != null || lhs.getFromElement().isImplied() ) {', 'label': 1}
{'comment': '//TODO: if we support multiple fetch groups, we would need //      to clone the set of lazy properties!', 'code': 'FieldInterceptionHelper.injectFieldInterceptor( entity, getEntityName(), lazyProps, session );', 'label': 1}
{'comment': '//TODO mappings.getLogicalTableName(ownerTable)', 'code': 'String logicalOwnerTableName = ownerTable.getName();', 'label': 1}
{'comment': '//TODO: always true for now, but not if we later decide to support elements() in the from clause', 'code': 'inElementsFunction = true;', 'label': 1}
{'comment': '// we could move this inside if we wanted to // tolerate collection initializations during // collection dirty checking:', 'code': 'prepareCollectionFlushes( persistenceContext );', 'label': 1}
{'comment': '//root entity comes *last*', 'code': 'resultTypeList.add( translator.getResultType( criteria ) );', 'label': 0}
{'comment': '//==elementType ??', 'code': 'else {', 'label': 0}
{'comment': "//scan the query string for class names appearing in the from clause and replace //with all persistent implementors of the class/interface, returning multiple //query strings (make sure we don't pick up a class in the select clause!)", 'code': '//TODO: this is one of the ugliest and most fragile pieces of code in Hibernate....', 'label': 0}
{'comment': '//identifier collections not supported for 1-to-many', 'code': 'if ( getFactory().getSettings().isCommentsEnabled() ) {', 'label': 0}
{'comment': '// potentialTrimCharacterArgIndex = 1 assumes that a // trim-specification has been specified.  we handle the // exception to that explicitly', 'code': 'int potentialTrimCharacterArgIndex = 1;', 'label': 0}
{'comment': '// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~', 'code': '// seems to not really...', 'label': 0}
{'comment': '// if the current depth is 0, the root thing being loaded is the // many-to-many collection itself.  Here, it is alright to use // an inner join...', 'code': 'list = s.createQuery( "from Human h inner join h.friends as f with f.nickName like \'bubba\'" )', 'label': 0}
{'comment': '// update removed rows fks to null', 'code': 'try {', 'label': 0}
{'comment': '//registerFunction( "trim", new StandardSQLFunction( "trim", Hibernate.STRING ) );', 'code': '"midnight_seconds",', 'label': 0}
{'comment': '"//\t\t\tbuf.append( selectFragment( lhsAlias, """" ) )//ignore suffix for collection columns!"', 'code': 'replace(', 'label': 0}
{'comment': '// initialize the Set of queried identifier spaces (ie. tables)', 'code': 'Iterator iter = collections.values().iterator();', 'label': 0}
{'comment': '//use suffix for the entity columns', 'code': '.toString();', 'label': 0}
{'comment': '// we got here because we assumed that an instance // with an assigned id was detached, when it was // really persistent', 'code': 'entityIsTransient(event, copyCache);', 'label': 0}
{'comment': '// the class hierarchy structure', 'code': 'private final String subquery;', 'label': 0}
{'comment': '// remove the current element from insertions. It will be added back later.', 'code': 'String entityName = action.getEntityName();', 'label': 0}
{'comment': '//private final String rootTableName;', 'code': 'private final String[] subclassClosure;', 'label': 0}
{'comment': '//INITIALIZATION:', 'code': 'public UnionSubclassEntityPersister(', 'label': 0}
{'comment': '//not null ... (start with 1) is implicit', 'code': '}', 'label': 0}
{'comment': '// continue loop', 'code': '}', 'label': 0}
{'comment': '// return existing object or initialized proxy (unless deleted)', 'code': 'LOG.trace( "Entity found in session cache" );', 'label': 0}
{'comment': '// the list of entity names that indicate the batch number', 'code': 'for ( EntityInsertAction action : (List<EntityInsertAction>) insertions ) {', 'label': 0}
{'comment': '//disassembled state gets put in a new array (we write to cache by value!)', 'code': 'this.disassembledState = TypeHelper.disassemble(', 'label': 0}
{'comment': '// Execute the SQL:', 'code': 'public String fromTableFragment(String name) {', 'label': 0}
{'comment': '//sort the updates by fk', 'code': 'java.util.Collections.sort( collectionCreations );', 'label': 0}
{'comment': '// This could also just be true all the time...', 'code': 'return isAbstract() || hasSubclasses();', 'label': 0}
{'comment': '// the mapping of entity names to their latest batch numbers.', 'code': 'private HashMap<String,Integer> latestBatches = new HashMap<String,Integer>();', 'label': 0}
{'comment': '//chop the last union (all)', 'code': 'buf.setLength( buf.length() - ( dialect.supportsUnionAll() ? 11 : 7 ) );', 'label': 0}
{'comment': '// note that for sequential scrolling, we make the assumption that // the first persister element is the "root entity"', 'code': 'if ( resultSet.isAfterLast() ) {', 'label': 0}
{'comment': '//TODO: check this....', 'code': 'return getTableName();', 'label': 0}
{'comment': '// 23000: Check constraint violation: {0} // 23001: Unique index or primary key violation: {0}', 'code': 'if ( sqle.getSQLState().startsWith( "23" ) ) {', 'label': 0}
{'comment': '// the closure of all properties in the entire hierarchy including // subclasses and superclasses of this class', 'code': 'private final int[] subclassPropertyTableNumberClosure;', 'label': 0}
{'comment': '//expressionTerminators.add(","); // deliberately excluded', 'code': 'EXPRESSION_OPENERS.add( "and" );', 'label': 0}
{'comment': '// subclass discrimination works by assigning particular // values to certain combinations of null primary key // values in the outer join using an SQL CASE', 'code': 'private final Map subclassesByDiscriminatorValue = new HashMap();', 'label': 0}
{'comment': '// Multi-param numeric dialect functions...', 'code': 'registerFunction( "atan2", new StandardSQLFunction("atan2", StandardBasicTypes.FLOAT) );', 'label': 0}
{'comment': '// Use theta style (for regression) // Move the node up, after the origin node.', 'code': 'FromElement origin = fromElement.getOrigin();', 'label': 0}
{'comment': '// Multi-param date dialect functions...', 'code': 'registerFunction( "add_months", new StandardSQLFunction("add_months", StandardBasicTypes.DATE) );', 'label': 0}
{'comment': '// SQLException support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~', 'code': '/**', 'label': 0}
{'comment': '// This assumes you will want to ignore any update counts', 'code': 'while ( !isResultSet && ps.getUpdateCount() != -1 ) {', 'label': 0}
{'comment': '//skip the FROM keyword in params', 'code': '/**', 'label': 0}
{'comment': '// Custom sql', 'code': 'final AnnotationInstance sqlLoaderAnnotation = JandexHelper.getSingleAnnotation(', 'label': 0}
{'comment': '// return a newly loaded object', 'code': 'return load(event, persister, keyToLoad, options);', 'label': 0}
{'comment': '// make it circular-reference safe', 'code': 'final EntityKey entityKey = session.generateEntityKey( entityId, subclassPersister );', 'label': 0}
{'comment': '//Cope with special cases of AND, NOT, ()', 'code': 'specialCasesBefore( lcToken );', 'label': 0}
{'comment': '// subclass closure properties', 'code': '//TODO: code duplication with SingleTableEntityPersister', 'label': 0}
{'comment': '// for dialects which are known to not support ANSI-SQL row-value-constructor syntax, // we should mutate the tree.', 'code': 'if ( !sessionFactory.getDialect().supportsRowValueConstructorSyntax() ) {', 'label': 0}
{'comment': '// we have the form: trim(from trimSource). //      This is functionally equivalent to trim(trimSource) // EARLY EXIT!!!!', 'code': 'return Arrays.asList( naturalIdLoadAccess.load() );', 'label': 0}
{'comment': '// SUBCLASSES', 'code': 'subclassByDiscriminatorValue.put(', 'label': 0}
{'comment': '//need to hydrate it.', 'code': '// grab its state from the ResultSet and keep it in the Session', 'label': 0}
{'comment': '//starts with 1, implicitly', 'code': '}', 'label': 0}
{'comment': '// instantiate a new instance', 'code': 'object = session.instantiate( instanceClass, key.getIdentifier() );', 'label': 0}
{'comment': '// simple nullability constraint', 'code': 'return null;', 'label': 0}
{'comment': '//we need to upgrade the lock mode to the mode requested', 'code': 'session.getPersistenceContext().getEntry(object)', 'label': 0}
{'comment': '"//\tregister the type of the out param - an Oracle specific type"', 'code': 'statement.registerOutParameter(col, oracletypes_cursor_value);', 'label': 0}
{'comment': '// look for a proxy', 'code': 'Object proxy = persistenceContext.getProxy(keyToLoad);', 'label': 0}
{'comment': '// features which change between 8i, 9i, and 10g ~~~~~~~~~~~~~~~~~~~~~~~~~~', 'code': '/**', 'label': 0}
{'comment': "// evicts don't cascade to uninitialized collections", 'code': 'return getLoadedElementsIterator(session, collectionType, collection);', 'label': 0}
{'comment': '// features which remain constant across 8i, 9i, and 10g ~~~~~~~~~~~~~~~~~~', 'code': '@Override', 'label': 0}
{'comment': '// need to treat this as if it where optimistic-lock="all" (dirty does *not* make sense); // first we need to locate the "loaded" state // // Note, it potentially could be a proxy, so perform the location the safe way...', 'code': '// Note, it potentially could be a proxy, so doAfterTransactionCompletion the location the safe way...', 'label': 0}
{'comment': '//( (Column) sc.getTable().getPrimaryKey().getColumnIterator().next() ).getName();', 'code': 'value.addColumn( new Column( columnName ) );', 'label': 0}
{'comment': '// might happen with a managed connection', 'code': '}', 'label': 0}
{'comment': "// don't need subclass tables, because they can't appear in conditions", 'code': '}', 'label': 0}
{'comment': '// not final-static to avoid possible classcast exceptions if using different oracle drivers.', 'code': 'int oracletypes_cursor_value = 0;', 'label': 0}
{'comment': '//private List aliases = new ArrayList();', 'code': 'private List columnAliases = new ArrayList();', 'label': 0}
{'comment': "// The reason for this is SQL doesn't let you sort by an expression you are // not returning in the result set.", 'code': 'private final PathExpressionParser pathExpressionParser;', 'label': 0}
{'comment': '//update all the modified entries', 'code': 'int count = doUpdateRows( id, collection, session );', 'label': 0}
{'comment': '// special case where we need to force incloude all subclass joins', 'code': 'q.addSelectScalar( getFunction( "count", q ).getReturnType( StandardBasicTypes.LONG, q.getFactory() ) );', 'label': 0}
{'comment': "// we did not find a collection element in the result set, so we // ensure that a collection is created with the owner's identifier, // since what we have is an empty collection", 'code': 'p.getIdentifierType(),', 'label': 0}
{'comment': '//getDefaultProperties().setProperty(Environment.STATEMENT_BATCH_SIZE, NO_BATCH);', 'code': 'public String getAddColumnString() {', 'label': 0}
{'comment': '// assumes that types are all of span 1', 'code': 'Iterator iter = namedParams.entrySet().iterator();', 'label': 0}
{'comment': '// hibernate impelemnts cast in Dialect.java', 'code': 'registerFunction( "ceiling", new StandardSQLFunction( "ceiling", StandardBasicTypes.INTEGER ) );', 'label': 0}
{'comment': '// this is the root (versioned) table, and we are using version-based // optimistic locking;  if we are not updating the version, also don\'t // check it (unless this is a "generated" version column)!', 'code': 'if ( checkVersion( includeProperty ) ) {', 'label': 0}
{'comment': '// aggregate functions shouldn\'t be registered, right? //registerFunction( "list", new StandardSQLFunction("list",Hibernate.STRING) ); // stopped on $list', 'code': '"midnight_seconds",', 'label': 0}
{'comment': '//its the given optional object', 'code': 'object = optionalObject;', 'label': 0}
{'comment': '//decide which ResultSet to get the property value from:', 'code': 'final boolean propertyIsDeferred = hasDeferred &&', 'label': 0}
{'comment': '// properties of this class, including inherited properties', 'code': 'public String getAuthoriser() {', 'label': 0}
{'comment': '// otherwise assume the parent is the the criteria that created us', 'code': 'parent = subcriteria.getParent();', 'label': 0}
{'comment': '// the closure of all columns used by the entire hierarchy including // subclasses and superclasses of this class', 'code': 'private final int[] subclassPropertyTableNumberClosure;', 'label': 0}
{'comment': '// we can go straight to the first required row', 'code': 'rs.absolute( firstRow );', 'label': 0}
{'comment': '// now look up the object we are really interested in! // (this lets us correctly handle proxies and multi-row // or multi-column queries)', 'code': '// (this lets us correctly handle proxies and multi-row or multi-column queries)', 'label': 0}
{'comment': '// discriminator column', 'code': 'if ( discriminatorColumnAnnotation != null ) {', 'label': 0}
{'comment': '// Code to handle subclasses of topClass', 'code': 'Object discriminatorValue = persister.getDiscriminatorType().nullSafeGet(', 'label': 0}
{'comment': '//NONE, because its the requested lock mode, not the actual!', 'code': 'defaultLockModes = ArrayHelper.fillArray( LockMode.NONE, size );', 'label': 0}
{'comment': '//private final Map propertyTableNumbersByName = new HashMap();', 'code': 'private final Map propertyTableNumbersByNameAndSubclass = new HashMap();', 'label': 0}
{'comment': "// conceivable that the dialect ctor could throw HibernateExceptions, so don't re-wrap", 'code': 'throw e;', 'label': 0}
{'comment': '// CLASS + TABLE', 'code': 'joinSpan = persistentClass.getJoinClosureSpan()+1;', 'label': 0}
{'comment': '// synchronized to avoid multi-thread access issues; defined as method synch to avoid // potential deadlock issues due to nature of code.', 'code': 'if ( session.getFactory().getSettings().isWrapResultSetsEnabled() ) {', 'label': 0}
{'comment': '// required to exception table // iconst_0 // i', 'code': 'code.addIconst( 0 );', 'label': 0}
{'comment': '// for now, just "re-flatten" the metamodel since this is temporary stuff anyway (HHH-1907)', 'code': 'this.isKey = metamodel.isKey();', 'label': 0}
{'comment': '// checkcast // cast the bean into a raw bean', 'code': 'code.addCheckcast( this.targetBean.getName() );', 'label': 0}
{'comment': '// checkcast (case of primitive type) // invokevirtual (case of primitive type)', 'code': 'code.addInvokevirtual( target_type_index, getterName, getter_desc );', 'label': 0}
{'comment': '/* | this | bean | args | i | raw bean | exception | */', 'code': 'if ( setters.length > 0 ) {', 'label': 0}
{'comment': '// Get the first child to be considered.  Sub-classes may do this differently in order to skip nodes that // are not select expressions (e.g. DISTINCT).', 'code': 'AST firstChild = getFirstSelectExpression();', 'label': 0}
{'comment': '// new // BulkAccessorException', 'code': 'code.addNew( BULKEXCEPTION_CLASS_NAME );', 'label': 0}
{'comment': '//"as" is not in KEYWORDS', 'code': '&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {', 'label': 0}
{'comment': '// getfield // get field "$JAVASSIST_CALLBACK" defined already', 'code': 'code.addOpcode(Opcode.GETFIELD);', 'label': 0}
{'comment': '// dup', 'code': '// same however.', 'label': 0}
{'comment': '// todo : move this to SF per HHH-3517; also see HHH-1907 and ComponentMetamodel', 'code': 'final ComponentTuplizerFactory componentTuplizerFactory = new ComponentTuplizerFactory();', 'label': 0}
{'comment': '// putfield // put field "$JAVASSIST_CALLBACK" defined already', 'code': 'code.addOpcode(Opcode.PUTFIELD);', 'label': 0}
{'comment': '/* local variables | this | callback | */', 'code': 'Bytecode code = new Bytecode(cp, 3, 3);', 'label': 0}
{'comment': '// find the batch number associated with the current association, if any.', 'code': 'Integer associationBatchNumber = entityBatchNumber.get( value );', 'label': 0}
{'comment': '// invokeinterface', 'code': 'code.addInvokeinterface( target_type_index, getterName, getter_desc, 1 );', 'label': 0}
{'comment': '// we *always* assume an instance with a null // identifier or no identifier property is unsaved!', 'code': 'if ( id == null ) {', 'label': 0}
{'comment': '// DDL support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~', 'code': '/**', 'label': 0}
{'comment': '"// seems to not really... //\tpublic boolean supportsRowValueConstructorSyntax() { //\t\treturn true; //\t}"', 'code': 'if (obj == null)', 'label': 0}
{'comment': "// below is for Cache' that don't have str in 2007.1 there is str and we register str directly", 'code': 'registerFunction( "str", new SQLFunctionTemplate( StandardBasicTypes.STRING, "cast(?1 as char varying)" ) );', 'label': 0}
{'comment': '// temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~', 'code': 'private final String[] propertyNames;', 'label': 0}
{'comment': '// byte', 'code': 'if ( Byte.TYPE.equals( javaType ) ) {', 'label': 0}
{'comment': '// the column doesnt exist at all.', 'code': 'StringBuilder alter = new StringBuilder( root.toString() )', 'label': 0}
{'comment': '// note that %string is deprecated', 'code': 'registerFunction( "%string", new VarArgsSQLFunction( StandardBasicTypes.STRING, "%string(", ",", ")" ) );', 'label': 0}
{'comment': '//If the object is already loaded, return the loaded one', 'code': 'object = session.getEntityUsingInterceptor( key );', 'label': 0}
{'comment': '// create new lock that times out immediately', 'code': 'Lock newLock = new Lock( ts, uuid, nextLockId.getAndIncrement(), null );', 'label': 0}
{'comment': '// we really could refresh the item if it // is not a lock, but it might be slower //return freshTimestamp < txTimestamp', 'code': 'BatchModeTransactionManager.getInstance().commit();', 'label': 0}
{'comment': '// Due to the complexity in initializing the SelectClause, do not generate one here. // If it is not found; simply return null... // // Also, do not cache since it gets generated well after we are created.', 'code': 'return ( SelectClause ) ASTUtil.findTypeInChildren( this, SqlTokenTypes.SELECT_CLAUSE );', 'label': 0}
{'comment': '// DISCRIMINATOR', 'code': 'bindDiscriminatorProperty( table, entity, subnode, mappings );', 'label': 0}
{'comment': '// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // Pre-flushing section // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~', 'code': '// HQL test', 'label': 0}
{'comment': '// %upper is deprecated', 'code': 'registerFunction( "%upper", new StandardSQLFunction( "%upper" ) );', 'label': 0}
{'comment': '// let this take precedence if defined, since it works for // assigned identifiers', 'code': 'Boolean result = entityMetamodel.getVersionProperty()', 'label': 0}
{'comment': '//throw new UnsupportedOperationException("Can\'t write to a readonly object");', 'code': '* Throws UnsupportedOperationException since this cache is read-only', 'label': 0}
{'comment': '// the contract of EntityTuplizer.determineConcreteSubclassEntityName says that returning null // is an indication that the specified entity-name (this.getEntityName) should be used.', 'code': 'return this;', 'label': 0}
{'comment': '// The syntax used to add a foreign key constraint to a table.', 'code': 'return new StringBuilder( 300 )', 'label': 0}
{'comment': '"//note: it is conceptually possible that a UserType could map null to //\t  a non-null value, so the following is arguable:"', 'code': 'if ( isNullableTable( j ) && isAllNull( fields, j ) ) {', 'label': 0}
{'comment': '// note: interfaces is assumed to already contain HibernateProxy.class', 'code': 'try {', 'label': 0}
{'comment': '// identifier-commalist', 'code': '.append( ") REFERENCES " )', 'label': 0}
{'comment': '//assembled state gets put in a new array (we read from cache by value!)', 'code': 'Object[] assembledProps = TypeHelper.assemble(', 'label': 0}
{'comment': '// we do not have to worry about queued additions to uninitialized // collections, since they can only occur for inverse collections!', 'code': 'Iterator elems = getElementsIterator( collection, session );', 'label': 0}
{'comment': '// disassemble named parameters', 'code': 'final Map<String,TypedValue> namedParameters;', 'label': 0}
{'comment': '// remove all collections for the entity from the session-level cache', 'code': 'if ( persister.hasCollections() ) {', 'label': 0}
{'comment': '// invokeinterface // callback.write*(..)', 'code': 'code.addInvokeinterface( target_type_index, getterName, getter_desc, 1 );', 'label': 0}
{'comment': '// moved up from AbstractEntityPersister ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~', 'code': 'private final SessionFactoryImplementor factory;', 'label': 0}
{'comment': '// JOINS', 'code': 'Iterator joinIter = persistentClass.getJoinClosureIterator();', 'label': 0}
{'comment': '// classes mentioned in extends not available - so put it in queue', 'code': 'Attribute packageAttribute = hibernateMappingElement.attribute( "package" );', 'label': 0}
{'comment': '//propertyTableNumbersByName.put( prop.getName(), join );', 'code': 'propertyTableNumbersByNameAndSubclass.put(', 'label': 0}
{'comment': '//Access cached SQL', 'code': 'protected boolean isDiscriminatorFormula() {', 'label': 0}
{'comment': '//figure out which tables need to be fetched', 'code': 'AbstractEntityPersister subclassPersister = (AbstractEntityPersister) persister;', 'label': 0}
{'comment': '"//\tprivate final List persisters = new ArrayList();"', 'code': 'private final Map alias2Return = new HashMap();', 'label': 0}
{'comment': '//figure out which columns are needed', 'code': 'ArrayList columnNumbers = new ArrayList();', 'label': 0}
{'comment': '// it is possible for this method to be called during flush processing, // so make certain that we do not accidently initialize an uninitialized proxy', 'code': '// so make certain that we do not accidentally initialize an uninitialized proxy', 'label': 0}
{'comment': '//figure out which formulas are needed', 'code': 'ArrayList formulaNumbers = new ArrayList();', 'label': 0}
{'comment': '//get em on the second pass!', 'code': 'columnReaders = (String[]) columnReadersByPropertyPath.get(foreignKeyProperty);', 'label': 0}
{'comment': '//render the SQL', 'code': 'return renderSelect(', 'label': 0}
{'comment': '// local cache, so we use synchronization', 'code': '@Override', 'label': 0}
{'comment': '// SQL strings', 'code': 'private String sqlVersionSelectString;', 'label': 0}
{'comment': '// IDENTITY support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~', 'code': '/**', 'label': 0}
{'comment': '//if there is no resulting row, return null', 'code': 'if ( !rs.next() ) {', 'label': 0}
{'comment': '// *load_1 // each type', 'code': 'addTypeDependDataLoad(code, finfo.getDescriptor(), 1);', 'label': 0}
{'comment': '// unfortunately not really safe to normalize this // to 1 as an initial value like we do the others // because we would not be able to control this if // we are using a sequence...', 'code': 'if (value.lt(1)) LOG.pooledOptimizerReportedInitialValue(value);', 'label': 0}
{'comment': "// select topic, syntax from information_schema.help // where section like 'Function%' order by section, topic // // see also ->  http://www.h2database.com/html/functions.html", 'code': '// Numeric Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~', 'label': 0}
{'comment': '// The optional SQL string defined in the where attribute', 'code': 'private final String sqlWhereString;', 'label': 0}
{'comment': '//pass this as an argument only to avoid double looking', 'code': 'SessionImplementor source) {', 'label': 0}
{'comment': '// for version properties marked as being generated, make sure they are "always" // generated; aka, "insert" is invalid; this is dis-allowed by the DTD, // but just to make sure...', 'code': 'if ( prop.getGeneration() == PropertyGeneration.INSERT ) {', 'label': 0}
{'comment': '//information about lazy properties of this class', 'code': 'private final String[] lazyPropertyNames;', 'label': 0}
{'comment': '// If there are any scalars (non-entities) selected, render the select column aliases.', 'code': 'renderScalarSelects( selectExpressions, fromClause );', 'label': 0}
{'comment': '//information about all columns/formulas in class hierarchy', 'code': 'private final String[] subclassColumnClosure;', 'label': 0}
{'comment': '// Inner classes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~', 'code': 'public final class Subcriteria implements Criteria, Serializable {', 'label': 0}
{'comment': '// ( (Column) discrim.getColumnIterator().next() ).setType(type);', 'code': '}', 'label': 0}
{'comment': '// dynamic filters attached to the class-level', 'code': 'private final FilterHelper filterHelper;', 'label': 0}
{'comment': '// the loaded owner will be set to null after the collection is removed, // so capture its value as the affected owner so it is accessible to // both pre- and post- events', 'code': 'this.affectedOwner = session.getPersistenceContext().getLoadedCollectionOwnerOrNull( collection );', 'label': 0}
{'comment': '// temporary table support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~', 'code': '/**', 'label': 0}
{'comment': '// CUSTOM SQL', 'code': 'handleCustomSQL( node, entity );', 'label': 0}
{'comment': '// cascade first, so that all unsaved objects get their // copy created before we actually copy //cascadeOnMerge(event, persister, entity, copyCache, Cascades.CASCADE_BEFORE_MERGE);', 'code': 'super.cascadeBeforeSave(source, persister, entity, copyCache);', 'label': 0}
{'comment': '// model.getKey().setType( new Type( model.getIdentifier() ) );', 'code': '.getColumnIterator() );', 'label': 0}
{'comment': '// The syntax used to add a column to a table', 'code': 'return " add column";', 'label': 0}
{'comment': "// simple, because we can't have a one-to-one or a collection  // (or even a property-ref) in a composite-element:", 'code': 'String[] aliasedLhsColumns = StringHelper.qualify(alias, lhsColumns);', 'label': 0}
{'comment': '// Completely optional cascading drop clause.', 'code': 'return "";', 'label': 0}
{'comment': '// PROPERTIES', 'code': 'Iterator iter = node.elementIterator();', 'label': 0}
{'comment': '// IDENTIFIER', 'code': 'identifierColumnSpan = persistentClass.getIdentifier().getColumnSpan();', 'label': 0}
{'comment': '// VERSION', 'code': 'bindVersioningProperty( table, subnode, mappings, name, entity, inheritedMetas );', 'label': 0}
{'comment': '//operations which cascade as far as the collection also cascade to collection elements', 'code': ');', 'label': 0}
{'comment': '//WHERE STRING', 'code': 'sqlWhereString = StringHelper.isNotEmpty( persistentClass.getWhere() ) ? "( " + persistentClass.getWhere() + ") " : null;', 'label': 0}
{'comment': '// The loop ensures atomicity of the // select + update even for no transaction // or read committed isolation level', 'code': 'statementLogger.logStatement( query, FormatStyle.BASIC.getFormatter() );', 'label': 0}
{'comment': '// SUBCLASS PROPERTY CLOSURE', 'code': 'ArrayList columns = new ArrayList();', 'label': 0}
{'comment': '//before add :-)', 'code': 'formnos[l] = -1;', 'label': 0}
{'comment': '// Handle any filters applied to the class level', 'code': 'filterHelper = new FilterHelper( persistentClass.getFilters(), factory );', 'label': 0}
{'comment': '// only one-to-one is lazy fetched', 'code': 'return null;', 'label': 0}
{'comment': '// replicate does cascade to uninitialized collections', 'code': 'return getLoadedElementsIterator(session, collectionType, collection);', 'label': 0}
{'comment': '//note early exit here:', 'code': 'return initializeLazyPropertiesFromCache( fieldName, entity, session, entry, cacheEntry );', 'label': 0}
{'comment': '// NOTE: this assumes something about how propertySelectFragment is implemented by the subclass!', 'code': '// was toUnqotedAliasStrings( getIdentiferColumnNames() ) before - now tried', 'label': 0}
{'comment': '//deliberately ignore return value!', 'code': 'resolvedJoinType = getJoinType( nullable, currentDepth );', 'label': 0}
{'comment': '//strip leading ", "', 'code': 'setText( text );', 'label': 0}
{'comment': '// if the metadata allowed proxy creation and caller did not request forceful eager loading, // generate a proxy', 'code': 'return persister.createProxy( id, this );', 'label': 0}
{'comment': '// If this from element is a collection and the path is a collection property (maxIndex, etc.) then // generate a sub-query.', 'code': '// requiring a sub-query then generate a sub-query.', 'label': 0}
{'comment': '//otherwise return the "hydrated" state (ie. associations are not resolved)', 'code': 'Type[] types = getPropertyTypes();', 'label': 0}
{'comment': '// The name of the SQL function that transforms a string to lowercase', 'code': 'return "lower";', 'label': 0}
{'comment': '//null owner ok??', 'code': '}', 'label': 0}
{'comment': '// automatically makes a column with the default name if none is specifed by XML', 'code': 'public static void bindSimpleValue(Element node, SimpleValue simpleValue, boolean isNullable,', 'label': 0}
{'comment': '// just ignore', 'code': '}', 'label': 0}
{'comment': '// this is the exception returned by ReflectHelper.getConstructor() if it cannot // locate an appropriate constructor', 'code': 'throw new DetailedSemanticException( "Unable to locate appropriate constructor on class [" + className + "]", e );', 'label': 0}
{'comment': '// ok in normal Hibernate usage to delete a detached entity; JPA however // forbids it, thus this is a hook for HEM to affect this behavior', 'code': '* We encountered a delete request on a transient instance.', 'label': 0}
{'comment': '// null sql means that the only lazy properties // are shared PK one-to-one associations which are // handled differently in the Type#nullSafeGet code...', 'code': 'ps = session.getTransactionCoordinator()', 'label': 0}
{'comment': '// if the property mapping consists of all formulas,  // make it non-updateable', 'code': 'return updateable && !ArrayHelper.isAllFalse( value.getColumnUpdateability() );', 'label': 0}
{'comment': '// the user specifically supplied insert="true", // which constitutes an illegal combo', 'code': 'throw new MappingException(', 'label': 0}
{'comment': '// if the property mapping consists of all formulas,  // make it insertable', 'code': '// make it non-updateable', 'label': 0}
{'comment': '//it might be an unwrapped collection reference! //try to find a wrapper (slowish)', 'code': 'Iterator<PersistentCollection> wrappers = collectionEntries.keyIterator();', 'label': 0}
{'comment': '//Custom SQL', 'code': '//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~', 'label': 0}
{'comment': '//tableName = mappings.getNamingStrategy().propertyToTableName( className, path );', 'code': 'Table ownerTable = collection.getOwner().getTable();', 'label': 0}
{'comment': '// return', 'code': 'return c;', 'label': 0}
{'comment': '// the entry will be removed after the flush, and will no longer // override the stale snapshot // This is now handled by removeEntity() in EntityDeleteAction //persistenceContext.removeDatabaseSnapshot(key);', 'code': '//session.getPersistenceContext().removeDatabaseSnapshot(key);', 'label': 0}
{'comment': '//bad cast', 'code': '}', 'label': 0}
{'comment': '"/*ArrayList list = new ArrayList();\t\t\tlist.addAll( getKey().getConstraintColumns() );\t\t\tlist.addAll( getIndex().getConstraintColumns() );\t\t\tgetCollectionTable().createUniqueKey(list);*/"', 'code': 'list.add(baz);', 'label': 0}
{'comment': '//property-refs for associations defined on a //component are not supported, so no need to slice', 'code': 'return lhsPersister.getPropertyColumnNames(propertyName);', 'label': 0}
{'comment': '// we have an embedded composite identifier', 'code': 'try {', 'label': 0}
{'comment': '//if there is no property-ref, assume the join //is to the subclass table (ie. the table of the //subclass that the association belongs to)', 'code': 'return lhsPersister.getSubclassPropertyTableName(propertyIndex);', 'label': 0}
{'comment': '//stops flush being called multiple times if this method is recursively called', 'code': 'try {', 'label': 0}
{'comment': '// Create a new FROM node for the referenced class.', 'code': 'String associatedEntityName = propertyType.getAssociatedEntityName();', 'label': 0}
{'comment': '// performance op to avoid the array search', 'code': 'return 0;', 'label': 0}
{'comment': '// now get an existing proxy for each row element (if there is one)', 'code': 'for ( int i = 0; i < entitySpan; i++ ) {', 'label': 0}
{'comment': '// ORPHAN DELETE (used for programmer error detection)', 'code': 'Attribute cascadeAtt = node.attribute( "cascade" );', 'label': 0}
{'comment': '// empty means no scoping', 'code': 'return dialectScopes.isEmpty() || dialectScopes.contains( dialect.getClass().getName() );', 'label': 0}
{'comment': "//Enable for HHH-440, which we don't like:", 'code': '/*if ( type.isComponentType() && !propertyName.equals(rootPropertyName) ) {', 'label': 0}
{'comment': '//this.forceCacheRefresh = forceCacheRefresh;', 'code': 'this.comment = comment;', 'label': 0}
{'comment': '// this is a collection initializer, so we must create a collection // for each of the passed-in keys, to account for the possibility // that the collection is empty and has no rows in the result set', 'code': 'CollectionPersister[] collectionPersisters = getCollectionPersisters();', 'label': 0}
{'comment': '// an "embedded" component (composite ids and unique) // note that this does not handle nested components', 'code': 'if ( component.getOwner().hasPojoRepresentation() ) {', 'label': 0}
{'comment': '// ALIASES', 'code': 'internalInitSubclassPropertyAliasesMap( null, model.getSubclassPropertyClosureIterator() );', 'label': 0}
{'comment': '// cache these since they are stateless // this one could even be static...', 'code': 'private final BackrefSetter setter; // this one could even be static...', 'label': 0}
{'comment': '// a nested composite element', 'code': 'bindComponent(', 'label': 0}
{'comment': '//Must occur after resolving identifiers!', 'code': 'if ( session.isEventSource() ) {', 'label': 0}
{'comment': '// Get the persister for the _subclass_', 'code': 'final Loadable persister = (Loadable) getFactory().getEntityPersister( instanceEntityName );', 'label': 0}
{'comment': "// aliases for composite-id's", 'code': 'if ( getIdentifierType().isComponentType() ) {', 'label': 0}
{'comment': '// Fetch embedded identifiers propertynames from the "virtual" identifier component', 'code': 'CompositeType componentId = ( CompositeType ) getIdentifierType();', 'label': 0}
{'comment': '// we need to grab the version value from the entity, otherwise // we have issues with generated-version entities that may have // multiple actions queued during the same flush', 'code': 'version = persister.getVersion( instance );', 'label': 0}
{'comment': '// embedded composite ids ( alias.idname1, alias.idname2 )', 'code': 'subclassPropertyAliases.put( idPropertyNames[i], new String[] { idAliases[i] } );', 'label': 0}
{'comment': '// NOTE: we need to do the wrap here even if its not "dirty", // because collections need wrapping but changes to _them_ // don\'t dirty the container. Also, for versioned data, we // need to wrap before calling searchForDirtyCollections', 'code': 'WrapVisitor visitor = new WrapVisitor(session);', 'label': 0}
{'comment': '// TODO: skip formulas?', 'code': 'l++;', 'label': 0}
{'comment': '// GUID support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~', 'code': '/**', 'label': 0}
{'comment': '// invokeinterface // invoke Enabled.getInterceptFieldCallback()', 'code': 'code.addInvokeinterface( target_type_index, getterName, getter_desc, 1 );', 'label': 0}
{'comment': '// hibernate seems to ignore this type...', 'code': 'registerColumnType( Types.BLOB, "BLOB" );', 'label': 0}
{'comment': "//don't need filters for the static loaders", 'code': 'uniqueKeyLoaders.put(', 'label': 0}
{'comment': '// The user requested a "greater" (i.e. more restrictive) form of // pessimistic lock', 'code': 'if ( entry.getStatus() != Status.MANAGED ) {', 'label': 0}
{'comment': '//do two passes, for collection property-ref!', 'code': 'initIdentifierPropertyPaths(mapping);', 'label': 0}
{'comment': '"/*public boolean dropTemporaryTableAfterUse() {\t\t//we have to, because postgres sets current tx\t\t//to rollback only after a failed create table\t\treturn true;\t}*/"', 'code': 'if (obj == null)', 'label': 0}
{'comment': '// select the correct row by either pk or rowid', 'code': 'if ( useRowId ) {', 'label': 0}
{'comment': '"//\t\t\toptimizer = getFactory().getSettings().getBytecodeProvider().getReflectionOptimizer( //\t\t\t\t\tmappedClass, getterNames, setterNames, propTypes //\t\t\t);"', 'code': 'default:', 'label': 0}
{'comment': '//TODO: eventually, rowIdName[j]', 'code': '}', 'label': 0}
{'comment': '//include the discriminator and class-level where, but not filters', 'code': '.append( persister.filterFragment( getAlias(), Collections.EMPTY_MAP ) );', 'label': 0}
{'comment': '//lazy = !join;', 'code': 'fetchStyle = join ? FetchMode.JOIN : FetchMode.SELECT;', 'label': 0}
{'comment': '//not absolutely necessary, but helps for some //equals()/hashCode() implementations', 'code': 'if ( componentTuplizer.hasParentProperty() ) {', 'label': 0}
{'comment': '// this is a property of the table, which we are updating', 'code': 'update.addColumns( getPropertyColumnNames(i),', 'label': 0}
{'comment': '// special shortcut for id properties, skip the join! // this must only occur at the _end_ of a path expression', 'code': 'metadata.getServiceRegistry()', 'label': 0}
{'comment': '"// IMPL NOTE : due to the delayed population of setters (setters cached // \t\tfor performance), we really cannot pro0perly define equality for // \t\tthis transformer"', 'code': 'isNaturalKeyLookup = isLookupByNaturalKey;', 'label': 0}
{'comment': '// ( (Column) ( (SimpleValue) ic.getIndex() ).getColumnIterator().next() // ).setNullable(false);', 'code': '.getColumnIterator() );', 'label': 0}
{'comment': '// we have a mapped identifier property and the root of // the incoming property path matched that identifier // property', 'code': 'property = identifierProperty;', 'label': 0}
{'comment': '// contained elements:', 'code': 'Iterator iter = node.elementIterator();', 'label': 0}
{'comment': '// for non-inverse one-to-many, with a not-null fk, add a backref!', 'code': 'String entityName = ( (OneToMany) collection.getElement() ).getReferencedEntityName();', 'label': 0}
{'comment': '// mappings might contain either the "raw" extends name (in the case of // an entity-name mapping) or a FQN (in the case of a POJO mapping).', 'code': 'if ( mappings.getClass( extendsName ) == null && mappings.getClass( getClassName( extendsName, mappings ) ) == null ) {', 'label': 0}
{'comment': '// for objects that came in via update()', 'code': '}', 'label': 0}
{'comment': '//use dialect default properties', 'code': 'final Properties properties = new Properties();', 'label': 0}
{'comment': '// increment the version number (if necessary)', 'code': 'final Object nextVersion = getNextVersion(event);', 'label': 0}
{'comment': '// The cache provider is needed when we either have second-level cache enabled // or query cache enabled.  Note that useSecondLevelCache is enabled by default', 'code': 'settings.setRegionFactory( createRegionFactory( properties, ( useSecondLevelCache || useQueryCache ), serviceRegistry ) );', 'label': 0}
{'comment': '//information about all properties in class hierarchy', 'code': 'private final String[] subclassPropertyNameClosure;', 'label': 0}
{'comment': '// Informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~', 'code': '/**', 'label': 0}
{'comment': '// we are using "all" or "dirty" property-based optimistic locking', 'code': 'boolean[] includeInWhere = entityMetamodel.getOptimisticLockStyle() == OptimisticLockStyle.ALL', 'label': 0}
{'comment': '// orphans should be deleted during save/update', 'code': 'return true;', 'label': 0}
{'comment': '// maybe a concrete SQLpropertyresult type, but Map is exactly what is required at the moment', 'code': 'Element discriminatorResult = returnElement.element("return-discriminator");', 'label': 0}
{'comment': '// for some reason the antlr.CommonAST initialization routines force // this method to get called twice.  The first time with an empty string', 'code': 'if ( StringHelper.isNotEmpty( s ) ) {', 'label': 0}
{'comment': '// do a check', 'code': 'boolean hasOrphanDelete = loadedPersister != null && loadedPersister.hasOrphanDelete();', 'label': 0}
{'comment': '"//\t\t\tsqlAliasSuffixes[i] = element.getColumnAliasSuffix();"', 'code': 'includeInSelect[i] = !element.isFetch();', 'label': 0}
{'comment': '//materialize associations (and initialize the object) later', 'code': 'hydratedObjects.add( object );', 'label': 0}
{'comment': '"//\tprivate ComponentTuplizerFactory componentTuplizerFactory; todo : HHH-3517 and HHH-1907"', 'code': 'private Interceptor interceptor;', 'label': 0}
{'comment': '// drop them in reverse order in case db needs it done that way...', 'code': '{', 'label': 0}
{'comment': '// the owning entity may have been deleted and its identifier unset due to // identifier-rollback; in which case, try to look up its identifier from // the persistence context', 'code': 'if ( session.getFactory().getSettings().isIdentifierRollbackEnabled() ) {', 'label': 0}
{'comment': '// build an array with indices equal to the total number // of actual returns in the result Hibernate will return // for this query (scalars + non-scalars)', 'code': 'resultRow = new Object[ columnProcessors.length ];', 'label': 0}
{'comment': '"//\tpublic ComponentTuplizerFactory getComponentTuplizerFactory() { //\t\treturn componentTuplizerFactory; //\t}"', 'code': '* Iterate the entity mappings', 'label': 0}
{'comment': '// Mckoi has no known variation of a "SELECT ... FOR UPDATE" syntax...', 'code': 'if ( lockMode==LockMode.PESSIMISTIC_FORCE_INCREMENT) {', 'label': 0}
{'comment': '// it is or was referenced _somewhere_', 'code': 'boolean ownerChanged = loadedPersister != currentPersister ||\t\t\t\t// if either its role changed,', 'label': 0}
{'comment': '// nothing to do; even if the operand is a parameter, no way we could // infer an appropriate expected type here', 'code': 'protected abstract BytecodeProvider buildBytecodeProvider();', 'label': 0}
{'comment': '// the root of the incoming property path matched one // of the embedded composite identifier properties', 'code': 'property = identifierProperty;', 'label': 0}
{'comment': '// add normal properties', 'code': 'for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {', 'label': 0}
{'comment': '// serialization ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~', 'code': 'private void writeObject(ObjectOutputStream oos) throws IOException {', 'label': 0}
{'comment': '// add the discriminator', 'code': 'if ( j == 0 ) {', 'label': 0}
{'comment': '// handles arrays and newly instantiated collections', 'code': 'return collectionType.getElementsIterator(collection, session);', 'label': 0}
{'comment': '// if either its role changed,', 'code': '!currentPersister', 'label': 0}
{'comment': '// we will need to create new entries', 'code': '}', 'label': 0}
{'comment': '// this piece is needed for usage in select clause', 'code': 'super.setDataType(propertyType);', 'label': 0}
{'comment': '// key is an entity involved with the operation performed by the listener; // value can be either a copy of the entity or the entity itself', 'code': 'private Map<Object,Object> copyToEntityMap = new IdentityHashMap<Object,Object>( 10 );', 'label': 0}
{'comment': '// Get the names of the columns used to link between the collection // owner and the collection elements.', 'code': 'String[] keyColumnNames = persister.getKeyColumnNames();', 'label': 0}
{'comment': "//let's assume that there is only one lazy fetch group, for now!", 'code': 'return result;', 'label': 0}
{'comment': '// more specifically : "? [op] datetime" //      1) if the operator is MINUS, the param needs to be of //          some datetime type //      2) if the operator is PLUS, the param needs to be of //          some numeric type', 'code': 'expectedType = getType() == HqlSqlTokenTypes.PLUS ? StandardBasicTypes.DOUBLE : rhType;', 'label': 0}
{'comment': "// don't even bother trying to read any further", 'code': 'return null;', 'label': 0}
{'comment': '// prepend value and type list with null for any positions before the wanted position.', 'code': 'for ( int i = 0; i < position - size; i++ ) {', 'label': 0}
{'comment': '//+ "_" + referencedColumnName not used for backward compatibility', 'code': '}', 'label': 0}
{'comment': '// static helper methods ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~', 'code': '/**', 'label': 0}
{'comment': '// Base Expectation impls ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~', 'code': 'public static class BasicExpectation implements Expectation {', 'label': 0}
{'comment': '// this property belongs on the table and is to be inserted', 'code': 'update.addColumns( getPropertyColumnNames(i),', 'label': 0}
{'comment': '// need to extract the component values and check for subtype replacements...', 'code': 'CompositeType componentType = ( CompositeType ) types[i];', 'label': 0}
{'comment': '// add the primary key', 'code': 'if ( j == 0 && identityInsert ) {', 'label': 0}
{'comment': '// Impl Note: allows multiple collection fetches as long as the // entire fecthed graph still "points back" to a single // root entity for return', 'code': 'errorIfDML();', 'label': 0}
{'comment': '// delegate already handles PK columns', 'code': 'if ( getFactory().getSettings().isCommentsEnabled() ) {', 'label': 0}
{'comment': '//ie. e.status==DELETED', 'code': 'if ( LOG.isTraceEnabled() ) {', 'label': 0}
{'comment': '// kept for backward compatibility until after the 3.1beta5 release of HA', 'code': '// TODO: is this still needed?', 'label': 0}
{'comment': '//if an exception occurs during flush, user must call rollback()', 'code': 'transactionCoordinator().getTransactionContext().managedFlush();', 'label': 0}
{'comment': '// Turn off includeSubclasses on all FromElements.', 'code': 'FromClause from = getCurrentFromClause();', 'label': 0}
{'comment': "// can't just return null here, since that would // cause an owning component to become null", 'code': 'return NOT_NULL_COLLECTION;', 'label': 0}
{'comment': '// the object is transient or detached', 'code': '// the entity is not associated with the session, so', 'label': 0}
{'comment': '// Now update only the tables with dirty properties (and the table with the version number)', 'code': 'if ( tableUpdateNeeded[j] ) {', 'label': 0}
{'comment': '// Render the SQL query', 'code': 'final PreparedStatement insert;', 'label': 0}
{'comment': '// We must return a valid RDMS/RSA command from this method to // prevent RDMS/RSA from issuing *ERROR 400', 'code': 'return "";', 'label': 0}
{'comment': "// Write the values of fields onto the prepared statement - we MUST use the state at the time the // insert was issued (cos of foreign key constraints). Not necessarily the object's current state", 'code': 'dehydrate( id, fields, null, notNull, propertyColumnInsertable, j, insert, session, index, false );', 'label': 0}
{'comment': '// registerColumnType(Types.VARBINARY, "CHARACTER($l)"); // registerColumnType(Types.BLOB, "CHARACTER($l)" );  // For use prior to CP 11.0 // registerColumnType(Types.CLOB, "CHARACTER($l)" );', 'code': '// Dialect method overrides ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~', 'label': 0}
{'comment': '//a proxy cannot be transient and it breaks ForeignKeys.isTransient', 'code': '&& ForeignKeys.isTransient( childEntityName, child, null, session ) ) {', 'label': 0}
{'comment': "//don't bother trying to update, we know there is no row there yet", 'code': 'isRowToUpdate = false;', 'label': 0}
{'comment': '// CHECK', 'code': 'Attribute chNode = node.attribute( "check" );', 'label': 0}
{'comment': '//if all fields are null, we might need to delete existing row', 'code': 'isRowToUpdate = true;', 'label': 0}
{'comment': "//note: updates to joined tables can't be batched...", 'code': 'if ( useBatch && updateBatchKey == null ) {', 'label': 0}
{'comment': '// String Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~', 'code': 'registerFunction( "ascii", new StandardSQLFunction( "ascii", StandardBasicTypes.INTEGER ) );', 'label': 0}
{'comment': '// starting index', 'code': 'final PreparedStatement update;', 'label': 0}
{'comment': '// object have been loaded with setReadOnly(true); HHH-2236', 'code': 'snapshot[ lazyPropertyNumbers[j] ] = lazyPropertyTypes[j].deepCopy( propValue, factory );', 'label': 0}
{'comment': '"//\tprivate List collectionOwnerAliases = new ArrayList(); //\tprivate List collectionAliases = new ArrayList(); //\tprivate List collectionPersisters = new ArrayList(); //\tprivate List collectionResults = new ArrayList();"', 'code': 'List collectionOwners = new ArrayList();', 'label': 0}
{'comment': '// Write any appropriate versioning conditional parameters', 'code': 'if ( useVersion && entityMetamodel.getOptimisticLockStyle() == OptimisticLockStyle.VERSION ) {', 'label': 0}
{'comment': '//check if the detached object being merged is the parent', 'code': 'Object unmergedInstance = mergeMap.get( entityEntryInstance );', 'label': 0}
{'comment': '//Render the SQL query', 'code': 'final PreparedStatement insert;', 'label': 0}
{'comment': '// determine if the collection elements are entities...', 'code': 'Type elementType = persister.getElementType();', 'label': 0}
{'comment': '// Do the key. The key is immutable so we can use the _current_ object state - not necessarily // the state at the time the delete was issued', 'code': 'getIdentifierType().nullSafeSet( delete, id, index, session );', 'label': 0}
{'comment': '// Let return-propertys override whatever the persister has for aliases.', 'code': 'columnAliases = ( String[] ) fieldResults.get(propertyName);', 'label': 0}
{'comment': '// We should use the _current_ object state (ie. after any updates that occurred during flush)', 'code': 'if ( useVersion ) {', 'label': 0}
{'comment': '// might need to run a different filter entirely after the flush // because the collection role may have changed', 'code': 'entry = persistenceContext.getCollectionEntryOrNull( collection );', 'label': 0}
{'comment': '// amazingly, these two will work because AbstractCollection // uses iterator() to fill the array', 'code': 'public Object[] toArray() {', 'label': 0}
{'comment': "// can't cache this stuff either (per-invocation) // we are given a map of user-alias -> lock mode // create a new map of sql-alias -> lock mode", 'code': 'final LockOptions lockOptions = parameters.getLockOptions();', 'label': 0}
{'comment': '"//note: dirtyFields==null means we had no snapshot, and we couldn\'t get one using select-before-update //\t  oldFields==null just means we had no snapshot to begin with (we might have used select-before-update to get the dirtyFields)"', 'code': 'final boolean[] tableUpdateNeeded = getTableUpdateNeeded( dirtyFields, hasDirtyCollection );', 'label': 0}
{'comment': '// loop through all the associations of the current entity and make sure that they are processed // before the current batch number', 'code': 'Object[] propertyValues = action.getState();', 'label': 0}
{'comment': '', 'code': '', 'label': 0}
---------------------------------
comment&code: // JUnit 4 wraps solo tests this way. We can extract // the original test name with a little hack.String name = test.toString();
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759099438786507
---------------------------------
comment&code: // XXX ignore attributes in a different NS ( maybe store them ? )String name = test.toString();
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758982092142105
---------------------------------
comment&code: //borrowed from TokenFilterTestthrow new SAXParseException("Unexpected attribute \"" + attrs.getQName(i) + "\"", context.locator);
true label: 1
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758769750595093
---------------------------------
comment&code: // XXX Move to Project ( so it is shared by all helpers )private String getFileString(String filename) throws IOException {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759006306529045
---------------------------------
comment&code: // What is the property supposed to be?String antFileProp = "ant.file." + context.getCurrentProjectName();
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758956015110016
---------------------------------
comment&code: // PR: Hack for ant-type value //  an ant-type is a component name which can // be namespaced, need to extract the name // and convert from qualified name to uri/namepropertyValue =
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675923354923725
---------------------------------
comment&code: // there's a convenient xsltc class version but data are // private so use package informationif (ANT_TYPE.equals(name)
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758956015110016
---------------------------------
comment&code: // stolen from org.apache.xerces.impl.XMLEntityManager#getUserDir() // of the Xerces-J team // which ASCII characters need to be escapedClass procVersion = Class.forName(procVersionClassName);
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758911311626434
---------------------------------
comment&code: // bingo append it. (this should normally not be done here)private static boolean[] gNeedEscaping = new boolean[128];
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759052872657776
---------------------------------
comment&code: // This is faintly ridiculous:parent.appendChild(copy);
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758928075432777
---------------------------------
comment&code: //cannot remove underscores due to protected visibility >:(ze.setCrc (EMPTY_CRC);
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675887033343315
---------------------------------
comment&code: // TODO not read, yet in a public setterprotected String str_encoding = "JPEG";
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759216785430908
---------------------------------
comment&code: //  PR: I do not know what to do if the object class //      has multiple defines //      but this is for logging only...private long granularity = FILE_UTILS.getFileTimestampGranularity();
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675925776362419
---------------------------------
comment&code: // not sure what could be the need of this...Class elementClass = o.getClass();
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759052872657776
---------------------------------
comment&code: // Experimental/Testing, will be removedres.setSystemId(JAXPUtils.getSystemId(outfile));
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758887097239494
---------------------------------
comment&code: // XXX should instead make a new ProtectionDomain with a CodeSource // corresponding to container.toURI().toURL() and the same // PermissionCollection as Project.class.protectionDomain hadif( name.startsWith( "toString:" )) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758965328335762
---------------------------------
comment&code: //this is really irritating; we need a way to set stuffreturn defineClass(classname, classData, 0, classData.length,
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759099438786507
---------------------------------
comment&code: //XXX // All this to convert source to destination directory according // to weblogic standards Can be written better... this is too hacky!String []args = cmd.getJavaCommand().getArguments();
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759192571043968
---------------------------------
comment&code: //silly hack to avoid stack overflow...jspFile = new File(files[i]);
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758965328335762
---------------------------------
comment&code: // XXX - should throw an exception instead?if (!readingFiles) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759131103754044
---------------------------------
comment&code: // Temporary - until we figure a better APIresult.append('\\');
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758911311626434
---------------------------------
comment&code: // There is a better way to save the context. This shouldn't // delegate to next, it's for backward compatibility only./** EXPERIMENTAL WILL_CHANGE
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.0167593602091074
---------------------------------
comment&code: // quick fix for Ant.java use of property before // initializing the project// delegate to next, it's for backward compat only.
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759157180786133
---------------------------------
comment&code: // XXX: we should use JCVS (www.ice.com/JCVS) instead of // command line execution so that we don't rely on having // native CVS stuff around (SM)addTaskDefinition(ANT_PROPERTY_TASK,
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759226098656654
---------------------------------
comment&code: "/*             * two reasons are mentioned in the API docs for File.list             * (1) dir is not a directory. This is impossible as             *     we wouldn't get here in this case.             * (2) an IO error occurred (why doesn't it throw an exception             *     then???)             */"// We can't do it ourselves as jCVS is GPLed, a third party task
true label: 1
predicted label: 0
non_satd_prob: 0.98324054479599 satd_prob: 0.016759470105171204
---------------------------------
comment&code: //     * @TODO using taskName here is brittle, as a user could override it. //     *       this should probably be modified to use the classname instead.throw new BuildException("IO error scanning directory "
true label: 1
predicted label: 0
non_satd_prob: 0.98324054479599 satd_prob: 0.01675942912697792
---------------------------------
comment&code: //these are pathological cases, but retained in case somebody //subclassed us.if ("execon".equals(getTaskName())) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675902120769024
---------------------------------
comment&code: // This is deprecated - use classespath in the futurereturn false;
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758956015110016
---------------------------------
comment&code: //XXX  this array stuff is a remnant of prev trials.. gotta remove.String[] sP = getSourcespath().list();
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758956015110016
---------------------------------
comment&code: "/**     * Set the number of milliseconds leeway to give before deciding a     * target is out of date.     * TODO: This is not yet used.     * @param granularity the granularity used to decide if a target is out of     *                    date.     */"args[j++] = "-d";
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.01675940677523613
---------------------------------
comment&code: // This may change, if we add advanced parsing capabilities.public void setGranularity(long granularity) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759036108851433
---------------------------------
comment&code: // We assume, that every output, jikes does, stands for an error/warning // XXX // Is this correct?parseStandardOutput(reader);
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759274527430534
---------------------------------
comment&code: // The line below is a hack: the system id must an URI, but it is not // cleat to get the URI of an resource, so just set the name of the // resource as a system id// TODO:
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759416088461876
---------------------------------
comment&code: // XXX what is the following doing? //     should it run if !javadoc4 && executable != null?src.setSystemId(resourceToURI(resource));
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675925776362419
---------------------------------
comment&code: // MAC OS 9 and previous //TODO: I have no idea how to get it, someone must fix itif (javadoc4 && sourceFileName.indexOf(" ") > -1) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.01675931178033352
---------------------------------
comment&code: //TODO: nothing appears to read this but is set using a public setter.return null;
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759201884269714
---------------------------------
comment&code: // XXX - we are committing CombiningChar and Extender hereprivate boolean spawn = false;
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759052872657776
---------------------------------
comment&code: "/*                 * XXX - failed to load the class properly.                 *                 * should we print a warning here?                 */"if (!Character.isLetterOrDigit(c)
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759172081947327
---------------------------------
comment&code: // XXX could perhaps also call thread.stop(); not sure if anyone caresreturn;
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675925776362419
---------------------------------
comment&code: "/**         * XXX         * Perhaps we shouldn't use properties for these         * three options (emacs mode, warnings and pedantic),         * but include it in the javac directive?         */"throw e;
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759376972913742
---------------------------------
comment&code: // XXX maybe use reflection to addPathElement (other patterns ?)* Jikes has the nice feature to print error
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759172081947327
---------------------------------
comment&code: // TODO there is a problem with the constructor for the RBC. // you have to provide the rules in the constructors - no setters // available.if (obj != null && !(obj instanceof AntClassLoader)) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759267076849937
---------------------------------
comment&code: // probably not the best choice, but it solves the problem of // relative paths in CLASSPATHthrow new BuildException("RuleBasedCollator not yet supported.");
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675923354923725
---------------------------------
comment&code: // Fix for invalid characters. If you think of more add to the list.path = path.replace('\\', '/');
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758950427174568
---------------------------------
comment&code: // Check it out; also ugly.StringBuffer modifiedClassName = new StringBuffer(className.length());
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675894297659397
---------------------------------
comment&code: //I can't get my head around this; is encoding treatment needed here?// Change the item to be checked out to a StarTeam File.
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759267076849937
---------------------------------
comment&code: //quick & dirty, to make nested mapped p-sets work:return
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758956015110016
---------------------------------
comment&code: // XXX is this code still necessary? is there any 1.2+ port? // Pull in *.zip from packages directoryfor (Enumeration e = setRefs.elements(); e.hasMoreElements();) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759131103754044
---------------------------------
comment&code: // only: the developer knows what (s)he is doingFileSet msZipFiles = new FileSet();
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758956015110016
---------------------------------
comment&code: // first: developer could use a little helpresult.addExisting(p, true);
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675902120769024
---------------------------------
comment&code: // XXX     should we silently catch possible exceptions and try to //         load a different implementation?result.addExisting(p, true);
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759226098656654
---------------------------------
comment&code: // since Java 1.4 //return normalizedPath.split("/"); // workaround for Java 1.2-1.3Throwable cause = null;
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675889641046524
---------------------------------
comment&code: // HAMMER // end inline mainGTUObject[] tokens = StringUtils.split(normalizedPath, '/').toArray();
true label: 1
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: "/**     * This array really shouldn't be here.     * Again, for historical purposes it is.     *     * <p>FIXME: This array should be in a private or package private     * location, since it could be modified by malicious code.</p>     */"fmap[j] = v;
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.01675933599472046
---------------------------------
comment&code: // Should move to a separate public class - and have API to add // listeners, etc.int[] rNums = {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675897277891636
---------------------------------
comment&code: // "" should become a single empty argument, same for '' // PR 5906private static class AntRefTable extends Hashtable {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758956015110016
---------------------------------
comment&code: // not very nice but will do the jobs = Commandline.translateCommandline("\"\" a");
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758950427174568
---------------------------------
comment&code: // provide public visibilityfail("process interrupted in thread");
true label: 1
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758818179368973
---------------------------------
comment&code: // not used, but public so theoretically must remain for BC?public String resolveFile(String file) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759052872657776
---------------------------------
comment&code: // super.validateAttributes(); // don't want to call this methodpublic void assertEqualContent(File expect, File result)
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759013757109642
---------------------------------
comment&code: // XXX what is this for?if (propertyFile != null) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759036108851433
---------------------------------
comment&code: // We keep this, so we have something to delete in later tests :-)}
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759172081947327
---------------------------------
comment&code: // *************  copied from ConcatTest  *************}
true label: 1
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: // not sure whether this is clean, but this method is // declared not to throw exceptions.// ------------------------------------------------------
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675923354923725
---------------------------------
comment&code: // We just set the prefix for this fileset, and pass it up. // Do we need to do this? LHthrow new IllegalStateException("Could not convert URI to path: "
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759399324655533
---------------------------------
comment&code: //why do we do nothing?fs.setPrefix("META-INF/");
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759082674980164
---------------------------------
comment&code: // This is the new, better way - use classespath instead // of sourcespath.  The code is currently the same - you // need class files in a directory to use this or jar files./**
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675925776362419
---------------------------------
comment&code: // XXX - why not simply new File(dir, filename)?String[] cP = getClassespath().list();
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675897277891636
---------------------------------
comment&code: // This is ugly; checking for the root folder.File file = getProject().resolveFile(new File(dir, filename).getPath());
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758956015110016
---------------------------------
comment&code: //TODO: Parameterise ?? //Call compiler as class... dont want to fork again //Use classic compiler -- can be parameterised?Folder f = v.getRootFolder();
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675928197801113
---------------------------------
comment&code: //XXX // All this to get package according to weblogic standards // Can be written better... this is too hacky! // Careful.. similar code in scanDir , but slightly different!!args[j++] =  "-compilerclass";
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759289428591728
---------------------------------
comment&code: //stolen from writeManifestString filename = (String) filesToDo.elementAt(i);
true label: 1
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675882562994957
---------------------------------
comment&code: "/* If the jarfile already exists then whack it and recreate it.             * Should probably think of a more elegant way to handle this             * so that in case of errors we don't leave people worse off             * than when we started =)             */"super.zipFile(service.getAsStream(), zOut,
true label: 1
predicted label: 0
non_satd_prob: 0.9832404255867004 satd_prob: 0.016759555786848068
---------------------------------
comment&code: // XXX is the following really necessary? it is in the same thread group...if (jarfile.exists()) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759123653173447
---------------------------------
comment&code: // we have to find a cleaner way to put this outputproject.registerThreadTask(thread, currentThreadTask);
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675902120769024
---------------------------------
comment&code: // This is the old way and is deprecated - classespath is // the right way to do this and is above}
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759226098656654
---------------------------------
comment&code: // For Script example that modifies id'ed tasks in other // targets to work. *very* Ugly // The reference is replaced by RuntimeConfigurableString[] sP = getSourcespath().list();
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.0167589969933033
---------------------------------
comment&code: // don't call super.close() because that reader is used // on other places ...this.getOwningTarget().replaceChild(this, (Task)realThing);
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759006306529045
---------------------------------
comment&code: // report error if something weird happens...this is diagnostic.if (appendReader != null) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759052872657776
---------------------------------
comment&code: // sorry - otherwise we will get a ClassCastException because the MockCache // is loaded by two different classloader ...if (error != null) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759082674980164
---------------------------------
comment&code: // ***HACK*** We ask the VM to create an instance // by voluntarily providing illegal arguments to force // the VM to run the class' static initializer, while // at the same time not running a valid constructor.sel.setClassLoader(this.getClass().getClassLoader());
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759052872657776
---------------------------------
comment&code: // Singleton for now, it may change ( per/classloader )final Constructor[] cons = theClass.getDeclaredConstructors();
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758928075432777
---------------------------------
comment&code: // XXX - shouldn't this always return false in isolated mode?return singleton;
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759226098656654
---------------------------------
comment&code: //TO DO : delete the file if it is not a valid file.boolean useParentFirst = parentFirst;
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675897277891636
---------------------------------
comment&code: "/** * TODO: * comment field doesn't include all options yet */"String msg = "Exception while calling " + VERIFY + " Details: "
true label: 1
predicted label: 0
non_satd_prob: 0.98324054479599 satd_prob: 0.01675942912697792
---------------------------------
comment&code: // Have to think about lazy initialization here...  JHM // comparator = new java.text.RuleBasedCollator();* Performs a ClearCase Unlock command.
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675906963646412
---------------------------------
comment&code: // XXX - log an error?  throw an exception?} else {
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675925776362419
---------------------------------
comment&code: // TODO: allow user to request the system or no parent}
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675918512046337
---------------------------------
comment&code: //if there was any text before this, add it as a fragment //TODO, this check could be modified to go if pos>prev; //seems like this current version could stick empty strings //into the listif (parent == null) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759274527430534
---------------------------------
comment&code: // XXX add exceptionsif (pos > 0) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675882562994957
---------------------------------
comment&code: // test a process that runs and failed} catch (Exception ex) {
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758903861045837
---------------------------------
comment&code: // ignorepublic void testFailed() throws Exception {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758769750595093
---------------------------------
comment&code: // process should abort}
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: // user:password@host:/path notationwatchdog.start(process);
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675877720117569
---------------------------------
comment&code: "/*          * @param event the build event that is being logged.         */"setUsername(uri.substring(0, indexOfColon));
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675884611904621
---------------------------------
comment&code: // only track progress for files larger than 100kb in verbose modepublic void messageLogged(BuildEvent event) {
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758933663368225
---------------------------------
comment&code: // Element doesn't handle text contentboolean trackProgress = getVerbose() && filesize > 102400;
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758879646658897
---------------------------------
comment&code: // send "C0644 filesize filename", where filename should not include '/'if (text.length() == 0) {
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675889641046524
---------------------------------
comment&code: // ClearCase itemslong filesize = localFile.length();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758745536208153
---------------------------------
comment&code: /* Assign actual codes for the tables. */if (getReserved()) {
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758838668465614
---------------------------------
comment&code: // -reservedsendMTFValues3(nGroups, alphaSize);
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: /* size of the central directory   */cmd.createArgument().setValue(FLAG_RESERVED);
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758818179368973
---------------------------------
comment&code: // gcj doesn't support an extension dir (-extdir) // so we'll emulate it for compatibility and convenience./* offset of start of central      */
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675914041697979
---------------------------------
comment&code: // At this point we are probably in failure mode, but // try to use the bare URI as a last gaspPath p = getBootClassPath();
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759131103754044
---------------------------------
comment&code: // -unreservedsource.setInputSource(new InputSource(uri));
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675875298678875
---------------------------------
comment&code: // DataType can have a "no arg" constructor or take a single // Project argument.cmd.createArgument().setValue(FLAG_UNRESERVED);
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675887033343315
---------------------------------
comment&code: // -outctor = newclass.getConstructor(new Class[0]);
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758745536208153
---------------------------------
comment&code: // b may be 0 for success, //          1 for error, //          2 for fatal error,getOutCommand(cmd);
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759157180786133
---------------------------------
comment&code: // Not whitespace - failif (b == -1) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675875298678875
---------------------------------
comment&code: // Fall truString msg = project.getElementName(element)
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675875298678875
---------------------------------
comment&code: // -ndata}
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758736222982407
---------------------------------
comment&code: // C0644 filesize filename - header for a regular file // T time 0 time 0\n - present if perserve time. // D directory - this is the header for a directory.cmd.createArgument().setValue(FLAG_NODATA);
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758911311626434
---------------------------------
comment&code: // -versionByteArrayOutputStream stream = new ByteArrayOutputStream();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675875298678875
---------------------------------
comment&code: //wince isn't really 9x, but crippled enough to //be a muchness. Ant doesnt run on CE, anyway.cmd.createArgument().setValue(FLAG_VERSION);
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675916463136673
---------------------------------
comment&code: // -nwarn|| OS_NAME.indexOf("ce") >= 0);
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758745536208153
---------------------------------
comment&code: // if a label has been supplied and it is a revision label, use the raw // the view as the snapshotcmd.createArgument().setValue(FLAG_NOWARN);
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758928075432777
---------------------------------
comment&code: // Class doesn't have a String constructor but a decent factory method} else if (this.isUsingRevisionLabel()) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758989542722702
---------------------------------
comment&code: /* total number of entries in      */} else if (java.lang.Class.class.equals(reflectedArg)) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758769750595093
---------------------------------
comment&code: // Check for \r, \r\n and \r\r\n // Regard \r\r not followed by \n as two lines/* the central dir on this disk    */ + 2
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758903861045837
---------------------------------
comment&code: // // Success!  The xml-commons resolver library is // available, so use it. //++eolcount;
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759036108851433
---------------------------------
comment&code: // it is a new file // set the revision but not the prevrevisioncatalogResolver = new ExternalResolver(clazz, obj);
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758956015110016
---------------------------------
comment&code: //catch script/ant mismatch with a meaningful message //we could ignore it, but there are likely to be other //version problems, so we stamp down on the configuration nowString filename = line.substring(0, index);
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675916463136673
---------------------------------
comment&code: // don't know the type, should throw exception instead?String msg = "Ant's Main method is being handed "
true label: 0
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675923354923725
---------------------------------
comment&code: // char and Character get special treatment - take the first characterreturn false;
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675880141556263
---------------------------------
comment&code: // do nothing} else if (java.lang.Character.class.equals(reflectedArg)) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675882562994957
---------------------------------
comment&code: // scan base dirs to build up compile lists only if a // specific classname is not given}
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758911311626434
---------------------------------
comment&code: // write a Properties file in each directory:if (classname == null) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675880141556263
---------------------------------
comment&code: // **   simple name specified   == parent dir + namefor (Iterator dirs = byDir.keySet().iterator(); dirs.hasNext();) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758769750595093
---------------------------------
comment&code: // requires version 2 as we are going to store length info // in the data descriptorwhile (searchParents && parent != null && parent.exists()) {
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758928075432777
---------------------------------
comment&code: // the test runner that wrap the dummy formatter that interests uswriteOut(ZipShort.getBytes(20));
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758862882852554
---------------------------------
comment&code: // CheckStyle:VisibilityModifier OFF - bcprivate final static class TestRunner extends JUnitTestRunner {
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758879646658897
---------------------------------
comment&code: // First try with Project./** The base directory to be scanned. */
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: // // The ResourceLocation may specify a relative path for its // location attribute.  This is resolved using the appropriate // base. //c = reflectedArg.getConstructor(new Class[] {Project.class, String.class});
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758928075432777
---------------------------------
comment&code: // Can return null to represent the bootstrap class loader. // see API docs of Class.getClassLoader.if (matchingEntry.getBase() != null) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: /* start of the central directory  */if (l != null) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675877720117569
---------------------------------
comment&code: //private static final int GET_ENTRY = 0;/* total number of entries in      */
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758810728788376
---------------------------------
comment&code: // file commentprivate static final int GET_FILE = 1;
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758736222982407
---------------------------------
comment&code: //There were no revisions in this changelog //entry so lets move onto next fileString comm = ze.getComment();
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759006306529045
---------------------------------
comment&code: //same date if dest timestamp is within granularity of the srcfilestatus = GET_FILE;
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: // must be "add"boolean sameDate;
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758769750595093
---------------------------------
comment&code: // ---------------------------------------------------------- // somewhat arbitrary choices that are quite common for shared // installations // -----------------------------------------------------------c.setValue("crlf");
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759052872657776
---------------------------------
comment&code: // EnumeratedAttributes have their own helper class//   Helper methods
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758879646658897
---------------------------------
comment&code: // selectors are implicitly ANDed in DirectoryScanner.  To // revert their logic we wrap them into a <none> selector // instead.} else if (EnumeratedAttribute.class.isAssignableFrom(reflectedArg)) {
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758950427174568
---------------------------------
comment&code: // first off, make sure that we've got a srcdir and destdirFileSelector[] s = syncTarget.getSelectors(getProject());
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758950427174568
---------------------------------
comment&code: // ZIPs store time with a granularity of 2 seconds, round upvalidate();
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758950427174568
---------------------------------
comment&code: // viewpathze.setTime(dir.lastModified() + (roundUp ? 1999 : 0));
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: // ------------------------------------------------------ //   Helper methods - should be in BuildFileTest // -----------------------------------------------------cmdl.createArgument().setValue(getViewPath());
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758956015110016
---------------------------------
comment&code: // build the command line from what we got the format is // cleartool lsco [options...] [viewpath ...] // as specified in the CLEARTOOL.EXE helpprivate boolean hasScript(String test) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759052872657776
---------------------------------
comment&code: // Check if list of files to check has been specifiedCommandline commandLine = new Commandline();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: // testNoCrash is the test invoked by the captureToSummary's junit taskif (!filesets.isEmpty()) {
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758911311626434
---------------------------------
comment&code: // if the two substrings are longer than the original, then name // contains address - so reset the name to nullprivate static final String PASS_TEST = "testNoCrash";
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758956015110016
---------------------------------
comment&code: //defaultif (this.name.length() + this.address.length() > len) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: // log options used// if this class belongs to a package which has been
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758956015110016
---------------------------------
comment&code: // dummy formatter just to catch the errorString enc = encoding == null ? "default" : encoding;
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758928075432777
---------------------------------
comment&code: // we don't expect to find thisprivate final static class ResultFormatter implements JUnitResultFormatter {
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758989542722702
---------------------------------
comment&code: // resolve relative paths through Projectloader.findClass("fubar");
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: //patch file into the fileset} else if (java.io.File.class.equals(reflectedArg)) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: // type valuefileset.setFile(file);
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758745536208153
---------------------------------
comment&code: // bit3 set to signal, we use a data descriptorgetTypeValueCommand(cmd);
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675884611904621
---------------------------------
comment&code: //underscores go in front of invalid start charswriteOut(ZipShort.getBytes(8));
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: // use to scan own archiveassertMapped(mangler, "0.jsp", "_0_jsp");
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675880141556263
---------------------------------
comment&code: "/** * Tests the {@link XSLTProcess} task. * XXX merge with {@link StyleTest}? * @since Ant 1.5 */"private ZipScanner zs;
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758989542722702
---------------------------------
comment&code: // it is a modified file // set the revision and the prevrevisionpublic void setLoaderRef(Reference r) {
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675889641046524
---------------------------------
comment&code: "/*             * throw in drive letters             */"String filename = line.substring(0, index);
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: //set our parent dirString driveSpec = "C:";
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758760437369347
---------------------------------
comment&code: "/*             * promised to eliminate consecutive slashes after drive letter.             */"srcDir = file.getParentFile();
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675902120769024
---------------------------------
comment&code: // -cfileassertEqualsIgnoreDriveCase(driveSpec + "\\",
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: // avoid multiple configurationsgetCommentFileCommand(cmd);
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758769750595093
---------------------------------
comment&code: /** Version to use for addXXX and addConfiguredXXX */boolean isConfigured = false;
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758950427174568
---------------------------------
comment&code: // Compare the destination with the temp fileprivate class AddNestedCreator extends NestedCreator {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675880141556263
---------------------------------
comment&code: // SMTP auth only allowed with MIME maillog("destFile exists", Project.MSG_DEBUG);
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675880141556263
---------------------------------
comment&code: // All three specified and all three exist -> trueif (!autoFound && ((user != null) || (password != null))
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: // an address to send from is requiredpublic void test10() {
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675884611904621
---------------------------------
comment&code: // File is not found in specified filepathif (from == null || from.getAddress() == null) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758818179368973
---------------------------------
comment&code: // set the character set if not done already (and required)public void testSearchInPathNotThere() {
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758911311626434
---------------------------------
comment&code: // 2 is != 0 and even, so it is considered // failure on any platform currently supported // by Execute#isFailure.if (charset != null) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759082674980164
---------------------------------
comment&code: // Eof has been reachedreturn 2;
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: //decide whether to copy the existing arg set, or //build a new one from the list of all args excluding the special //operations that only we handlereachedEof = true;
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675902120769024
---------------------------------
comment&code: // typeif (argList.size() == args.length) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758736222982407
---------------------------------
comment&code: // wait for TIME_OUT/2, there should be about TIME_OUT/2 ms remaining before timeoutString oldValue = (String) props.get(key);
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759028658270836
---------------------------------
comment&code: "/*                fragments.addElement(value.substring(pos + 1, pos + 2));                prev = pos + 2;                */"thread.join(TIME_OUT/2);
true label: 0
predicted label: 0
non_satd_prob: 0.9832414388656616 satd_prob: 0.016758598387241364
---------------------------------
comment&code: // Well, no matching constructor.if (value.charAt(pos + 1) == '$') {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675880141556263
---------------------------------
comment&code: //check that dir and src are incompatiblereturn null;
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675880141556263
---------------------------------
comment&code: // OK, try without.f.setSrc(new File("example.zip"));
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675884611904621
---------------------------------
comment&code: // Set up a VSSHistory tasktry {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675875298678875
---------------------------------
comment&code: // -ptimeMSVSSHISTORY vssHistory = new MSVSSHISTORY();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675880141556263
---------------------------------
comment&code: // Throws EjbcException if unsuccessfulcmd.createArgument().setValue(FLAG_PRESERVETIME);
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758838668465614
---------------------------------
comment&code: // tests one the file objectEjbInfo[] ejbs = getEjbs(); // Returns list of EJBs for processing
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758903861045837
---------------------------------
comment&code: // Make a limited attempt to extract a sanitized name and email address // Algorithm based on the one found in Ant's MailMessage.javaassertTrue("No index.html present. Not generated?", reportFile.exists() );
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675897277891636
---------------------------------
comment&code: // if at eolcount == 0 and trailing characters of string // are CTRL-Zs, set eofStrpublic EmailAddress(String email) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: // We have extra elementsif (eolcount == 0) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758810728788376
---------------------------------
comment&code: // -keepfail("extra args");
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675875298678875
---------------------------------
comment&code: // keep searching for the first ^Zcmd.createArgument().setValue(FLAG_KEEPCOPY);
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675882562994957
---------------------------------
comment&code: // -identical}
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758745536208153
---------------------------------
comment&code: // conversion to URL via FileUtils like in XMLResultAggregator, not as suggested in the bug reportcmd.createArgument().setValue(FLAG_IDENTICAL);
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758956015110016
---------------------------------
comment&code: // Trailing characters are ^Zs // Construct new line and eofStrURL reportUrl = new URL( FileUtils.getFileUtils().toURI(reportFile.getAbsolutePath()) );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: // Check for required attributeseofStr.append(line.toString().substring(i + 1));
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758736222982407
---------------------------------
comment&code: // DO NOTHINGif (getTypeName() == null) {
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758879646658897
---------------------------------
comment&code: // permissible values for compression attribute}
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675877720117569
---------------------------------
comment&code: // build the command line from what we got. the format is // cleartool mkattr [options...] [viewpath ...] // as specified in the CLEARTOOL help/**
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759077087044716
---------------------------------
comment&code: // use COUNT as the default.  This mimics the old behavior, although // NONE might be a better option moving forward in the case of callablereturn ExecuteUpdateResultCheckStyle.COUNT;
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675925776362419
---------------------------------
comment&code: //perhaps not really necessary...String sequentialSelect = generateSequentialSelect(loadable);
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758956015110016
---------------------------------
comment&code: // todo : what else to do here?return null;
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759242862462997
---------------------------------
comment&code: //TODO: disable batch loading if lockMode > READ?return BatchingEntityLoaderBuilder.getBuilder( getFactory() )
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759131103754044
---------------------------------
comment&code: // turn hibernate.c3p0.* into c3p0.*, so c3p0 // gets a chance to see all hibernate.c3p0.*for ( Object o : props.keySet() ) {
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758911311626434
---------------------------------
comment&code: // todo: this was added to support initializing an entity's EntityEntry snapshot during reattach; // this should be refactored to instead expose a method to assemble a EntityEntry based on this // state for return.public Serializable[] getDisassembledState();
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759192571043968
---------------------------------
comment&code: // Do we need to drop constraints before dropping tables in this dialect?return true;
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675923354923725
---------------------------------
comment&code: "/**     * FIXME Per the RegionFactory class Javadoc, this constructor version     * should not be necessary.     *      * @param props The configuration properties     */"*           Environmental properties; currently unused.
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759242862462997
---------------------------------
comment&code: // Does this dialect support check constraints?return false;
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759006306529045
---------------------------------
comment&code: // this is done here 'cos we might only know the type here (ugly!) // TODO: improve this a lot:if ( value instanceof ToOne ) {
true label: 1
predicted label: 0
non_satd_prob: 0.98324054479599 satd_prob: 0.016759492456912994
---------------------------------
comment&code: // Does this dialect support the FOR UPDATE syntax?return false;
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759082674980164
---------------------------------
comment&code: // todo : what is the implication of this?id.setDynamic( !entity.hasPojoRepresentation() );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675902120769024
---------------------------------
comment&code: // todo : YUCK!!!optimizer = Environment.getBytecodeProvider().getReflectionOptimizer( mappedClass, getterNames, setterNames, propTypes );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759006306529045
---------------------------------
comment&code: // todo : again, how *should* this work for non-pojo entities?if ( component.getOwner().hasPojoRepresentation() ) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675918512046337
---------------------------------
comment&code: // Does this dialect support FOR UPDATE OF, allowing particular rows to be locked?return false;
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759267076849937
---------------------------------
comment&code: //TODO: really bad, evil hack to fix!!!mappings.addSecondPass( new ManyToOneSecondPass(manyToOne) );
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.01675933599472046
---------------------------------
comment&code: //aliasRefNode.resolve( false, false, aliasRefNode.getText() ); //TODO: is it kosher to do it here? //TODO: is it kosher to do it here?aliasRefNode.resolve( false, false ); //TODO: is it kosher to do it here?
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.01675940677523613
---------------------------------
comment&code: //TODO: better to degrade to lazy="false" if uninstrumented}
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759289428591728
---------------------------------
comment&code: // Does this dialect support the Oracle-style FOR UPDATE NOWAIT syntax?return false;
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759192571043968
---------------------------------
comment&code: //Icky workaround for MySQL bug:!( dialect instanceof MySQLDialect ) ||
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675911620259285
---------------------------------
comment&code: // we have to set up the table later!! yuck}
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758965328335762
---------------------------------
comment&code: //TODO: Somehow add the newly created foreign keys to the internal collectionLOG.debug( "Creating tables' unique integer identifiers" );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759077087044716
---------------------------------
comment&code: // This inner class implements a case statement....perhaps im being a bit over-clever hereabstract static class CollectionType {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759099438786507
---------------------------------
comment&code: //TODO: merge into one method!cascadeBeforeSave(source, persister, entity, createCache);
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759147867560387
---------------------------------
comment&code: // TODO: this is a bit of copy/paste from IndexedCollection.createPrimaryKey()boolean indexIsFormula = false;
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759181395173073
---------------------------------
comment&code: //TODO: inefficientCacheEntry ce = persister.buildCacheEntry( instance,state, nextVersion, getSession() );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675911620259285
---------------------------------
comment&code: //FIXME: get the PersistentClassjava.util.Map propertyResults = bindPropertyResults(alias, returnElem, null, mappings );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759006306529045
---------------------------------
comment&code: //TODO: this is too conservative; if all preceding joins were  //      also inner joins, we could use an inner join here// IMPL NOTE : currentDepth might be less-than zero if this is the
true label: 1
predicted label: 0
non_satd_prob: 0.98324054479599 satd_prob: 0.016759445890784264
---------------------------------
comment&code: //TODO: redesign how PropertyAccessors are acquired...Property property = (Property) itr.next();
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675914041697979
---------------------------------
comment&code: // TODO : not so sure this is needed...throw new QueryException( "duplicate association path: " + wholeAssociationPath );
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.01675931178033352
---------------------------------
comment&code: //create an index on the key columns??}
true label: 1
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675877720117569
---------------------------------
comment&code: "/* TODO: joinKeyColumnName & foreignKeyColumnName should be called either here or at a			 * slightly higer level in the stack (to get all the information we need)			 * Right now HbmBinder does not support the			 */"* Right now HbmMetadataSourceProcessorImpl does not support the
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759302467107773
---------------------------------
comment&code: //ick!}
true label: 1
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758769750595093
---------------------------------
comment&code: // TODO: this is very suboptimal for some subclasses (namely components), // since it does not take advantage of two-phase-loadreturn nullSafeGet(rs, names, session, owner);
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759328544139862
---------------------------------
comment&code: //TODO: should this be Session.instantiate(Persister, ...)?copyCache.put( original, copy );
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759250313043594
---------------------------------
comment&code: //TODO: suck this into initLaziness!if ( "extra".equals( node.attributeValue("lazy") ) ) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759192571043968
---------------------------------
comment&code: //TODO: is this right??}
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759289428591728
---------------------------------
comment&code: //ie. the subquery! yuck!}
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758862882852554
---------------------------------
comment&code: //use of a stringbuffer to workaround a JDK bugreturn new StringBuffer( ownerEntityTable ).append( "_" )
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758911311626434
---------------------------------
comment&code: //TODO: copy/paste from recreate()offset = writeKey( st, id, offset, session );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675914041697979
---------------------------------
comment&code: //workaround, for backward compatibility of sets with no //not-null columns, assume all columns are used in the //row locator SQLif ( !hasNotNullableColumns ) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759006306529045
---------------------------------
comment&code: // todo : this eventually needs to be removedpublic static PropertyAccessor getPropertyAccessor(Class optionalClass, String type) throws MappingException {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758989542722702
---------------------------------
comment&code: // todo : removepublic Getter getGetter(Class clazz) throws PropertyNotFoundException, MappingException {
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675894297659397
---------------------------------
comment&code: //just to help out during the load (ugly, i know)private transient Class elementClass;
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759006306529045
---------------------------------
comment&code: // hack/workaround as sqlquery impl depend on having a key.}
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675902120769024
---------------------------------
comment&code: //TODO: handle the case of a foreign key to something other than the pkcreateForeignKeyOfEntity( ( (EntityType) getType() ).getAssociatedEntityName() );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675909198820591
---------------------------------
comment&code: //TODO: assumes all collections disassemble to an array!return (Serializable[]) state;
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759147867560387
---------------------------------
comment&code: //TODO: deprecated, remove eventually) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675923354923725
---------------------------------
comment&code: //TODO possibly relax thatthrow new DuplicateMappingException(
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675906963646412
---------------------------------
comment&code: // TODO : this is a bit dodgy, come up with a better way to check this (plus see above comment)String [] idColNames = owner.getQueryable().getIdentifierColumnNames();
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675925776362419
---------------------------------
comment&code: //use a degenerated strategy for backward compatibilityreturn StringHelper.unqualify(propertyName);
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675894297659397
---------------------------------
comment&code: //TODO: this is temporary in that the end result will probably not take a Property reference per-se.if ( null == mode || EntityMode.POJO.equals( mode ) ) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675923354923725
---------------------------------
comment&code: // todo : better to handle dynamic filters through implicit DynamicFilterParameterSpecification // see the discussion there in DynamicFilterParameterSpecification's javadocs as to why // it is currently not done that way.int filteredParamCount = queryParameters.getFilteredPositionalParameterTypes() == null
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759131103754044
---------------------------------
comment&code: // TODO: should "record" how many properties we have reffered to - and if we  //       don't get'em'all we throw an exception! Way better than trial and error ;)private String substituteBrackets(String sqlQuery) throws QueryException {
true label: 1
predicted label: 0
non_satd_prob: 0.98324054479599 satd_prob: 0.01675942912697792
---------------------------------
comment&code: //TODO: this dependency is kinda Badprivate static final PropertyAccessor BASIC_PROPERTY_ACCESSOR = new BasicPropertyAccessor();
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759052872657776
---------------------------------
comment&code: //TODO: get SQL rendering out of this package!}
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675920933485031
---------------------------------
comment&code: // why does this matter?if ( oj.getJoinable().isCollection() ) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759013757109642
---------------------------------
comment&code: // important, to account for newly saved entities in query // todo : some kind of check for new status...LOG.trace( "Owning entity already loaded; ignoring" );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759172081947327
---------------------------------
comment&code: //TODO: can we *always* use the "null property" approach for everything?/*if ( isPrimaryKey && !isSpecialOneToOne ) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759274527430534
---------------------------------
comment&code: // todo : remove this and just have subclasses use Isolater/IsolatedWork directly...public Getter getGetter(Class clazz) throws PropertyNotFoundException, MappingException {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759052872657776
---------------------------------
comment&code: // sql-server, at least needed this dropped after use; strange!}
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675906963646412
---------------------------------
comment&code: // is it necessary to register %exact since it can only appear in a where clause?registerFunction( "%exact", new StandardSQLFunction( "%exact", StandardBasicTypes.STRING ) );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675902120769024
---------------------------------
comment&code: // Does this dialect support the ALTER TABLE syntax?return true;
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759028658270836
---------------------------------
comment&code: // This next bit is to allow for both unsaved-value="negative" // and for "older" behavior where version number did not get // seeded if it was already set in the object // TODO: shift it into unsaved-value strategy( (initialVersion instanceof Number) && ( (Number) initialVersion ).longValue()<0 )
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759274527430534
---------------------------------
comment&code: //TODO: reenable if we also fix the above todo/*EntityPersister persister = getEntityPersister();
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759226098656654
---------------------------------
comment&code: // orphans should not be deleted during merge??return false;
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758956015110016
---------------------------------
comment&code: //TODO: suck this logic into the collection!final Collection orphans;
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675918512046337
---------------------------------
comment&code: // todo : we can actually just determine this from the incoming EntityEntry-srtn.hasNonReadOnlyEntities = ois.readBoolean();
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675904355943203
---------------------------------
comment&code: //TODO: this bit actually has to be called after all cascades! //      but since identity insert is called *synchronously*, //      instead of asynchronously as other actions, it isn't/*if ( persister.hasCache() && !persister.isCacheInvalidationRequired() ) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759216785430908
---------------------------------
comment&code: // this class has no proxies (so do a shortcut)if (!persister.hasProxy()) {
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758933663368225
---------------------------------
comment&code: // todo : need map? the prob is a proper key, right?public EntityLoadContext(LoadContexts loadContexts, ResultSet resultSet) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759131103754044
---------------------------------
comment&code: //TODO: better to pass the id in as an argument?if (LOG.isDebugEnabled()) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759274527430534
---------------------------------
comment&code: //do we even really need this? the update will fail anyway....if ( session.getFactory().getStatistics().isStatisticsEnabled() ) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675918512046337
---------------------------------
comment&code: //TODO: would it be better to do a refresh from db?}
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759399324655533
---------------------------------
comment&code: //TODO: ugly here:final String queryString = queryParameters.getFilteredSQL();
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759192571043968
---------------------------------
comment&code: //TODO: not quite sure about the full implications of this!addExtraJoins( joinFragment, rootAlias, rootJoinable, true );
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759289428591728
---------------------------------
comment&code: // todo : i'd much rather have this done from #endLoadingCollection(CollectionPersister,LoadingCollectionEntry)...loadContexts.unregisterLoadingCollectionXRef( collectionKey );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759036108851433
---------------------------------
comment&code: //PostLoad is needed for EJB3 //TODO: reuse the PostLoadEvent...PostLoadEvent postLoadEvent = new PostLoadEvent( session )
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759106889367104
---------------------------------
comment&code: // todo : should we check the current isolation mode explicitly?Object nextVersion = persister.forceVersionIncrement(
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759181395173073
---------------------------------
comment&code: // brand new collection //TODO: or an array!! we can't lock objects with arrays now??throw new HibernateException( "reassociated object has dirty collection reference (or an array)" );
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675923354923725
---------------------------------
comment&code: // null or brand new collection // this will also (inefficiently) handle arrays, which have // no snapshot, so we can't do any betterremoveCollection(persister, collectionKey, session);
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759172081947327
---------------------------------
comment&code: // TODO : perhaps we should additionally require that the incoming entity // version be equivalent to the defined unsaved-value?return changed && existsInDatabase( target, source, persister );
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.01675933599472046
---------------------------------
comment&code: "/** * Provides query splitting methods, which were originally in QueryTranslator. * <br> * TODO: This will need to be refactored at some point. * * @author josh */"public final class NameGenerator {
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759296879172325
---------------------------------
comment&code: // TODO : most of below was taken verbatim from DotNode; should either delegate this logic or super-type itCollectionType type = (CollectionType) getDataType();
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675925776362419
---------------------------------
comment&code: // TODO : better way?!?( ( DotNode ) dot ).setPropertyPath( ( ( FromReferenceNode ) property ).getPath() );
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759201884269714
---------------------------------
comment&code: // Not possible to simply re-use the versionPropertyNode here as it causes // OOM errors due to circularity :(versionIncrementNode = getASTFactory().create( HqlSqlTokenTypes.PLUS, "+" );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759082674980164
---------------------------------
comment&code: //TODO:this is only needed during compilation .. can we eliminate the instvar?private boolean compiled;
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675928197801113
---------------------------------
comment&code: //TODO: is this a bit ugly?expr.setText( text );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759172081947327
---------------------------------
comment&code: //TODO: switch statements are always evil! We already had bugs because  //      of forgotten token types. Use polymorphism for this!switch ( x.getType() ) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759343445301056
---------------------------------
comment&code: //TODO: used to be exprNoParens! was this needed?}
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.0167593602091074
---------------------------------
comment&code: // TODO : we may also want to check that the types here map to exactly one column/JDBC-type //      can't think of a situation where arithmetic expression between multi-column mappings //      makes any sense.Node lhs = getLeftHandOperand();
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759319230914116
---------------------------------
comment&code: // we do not know either type //BLIND GUESS!return StandardBasicTypes.DOUBLE; //BLIND GUESS!
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675911620259285
---------------------------------
comment&code: // TODO: get SQL rendering out of here, create an AST for the join expressions. // Use the SQL generator grammar to generate the SQL text for the index expression.JoinSequence joinSequence = fromElement.getJoinSequence();
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675920933485031
---------------------------------
comment&code: // not absolutely necessary, but does help with aggressive release//session.getJDBCContext().getConnectionManager().closeQueryStatement( ps, resultSet );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758989542722702
---------------------------------
comment&code: //TODO: this is one of the ugliest and most fragile pieces of code in Hibernate....String[] tokens = StringHelper.split( StringHelper.WHITESPACE + "(),", query, true );
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759201884269714
---------------------------------
comment&code: //yuck!Fo fo = Fo.newFo( (FumCompositeID) id );
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758911311626434
---------------------------------
comment&code: // ignore it; the incoming property could not be found so we // cannot be sure what to do here.  At the very least, the // safest is to simply not apply any dereference toggling...public boolean isDereferencedBySuperclassProperty() {
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675923354923725
---------------------------------
comment&code: // yuck!Fo fo = Fo.newFo( (FumCompositeID) id );
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758928075432777
---------------------------------
comment&code: // todo : potentially look at optimizing these two arraysoos.writeObject( loadedState );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759006306529045
---------------------------------
comment&code: //note that i parameter is now unused (delete it?)/**
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758933663368225
---------------------------------
comment&code: // TODO: Figure out a better way to get the FROM elements in a proper tree structure. // If this is not the destination of a many-to-many, add it as a child of the origin.if ( manyToMany ) {
true label: 1
predicted label: 0
non_satd_prob: 0.98324054479599 satd_prob: 0.016759438440203667
---------------------------------
comment&code: // TODO : this constructor form is *only* used from constructor directly below us; can it go away?super( sql, flushMode, session, parameterMetadata );
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.01675938256084919
---------------------------------
comment&code: // We should reengineer this class so that, rather than the current ad - // hoc linear approach to processing a stream of tokens, we instead // build up a tree of expressions.// We would probably refactor to have LogicParser (builds a tree of simple
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759399324655533
---------------------------------
comment&code: // todo : should this get moved to PersistentContext? // logically, is PersistentContext the "thing" to which an interceptor gets attached?final Object result = persistenceContext.getEntity(key);
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759192571043968
---------------------------------
comment&code: // TODO: something much better - look at the type of the other expression! // TODO: Have comparisonExpression and/or arithmeticExpression rules complete the resolution of boolean nodes.String replacement = ( String ) walker.getTokenReplacements().get( constant.getText() );
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759274527430534
---------------------------------
comment&code: //TODO: this class does too many things! we need a different //kind of path expression parser for each of the diffferent //ways in which path expressions can occur//We should actually rework this class to not implement Parser
true label: 1
predicted label: 0
non_satd_prob: 0.9832404255867004 satd_prob: 0.01675954833626747
---------------------------------
comment&code: //TODO: optimize this better!return index==-1 ? 0 : getSubclassPropertyTableNumber(index);
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759181395173073
---------------------------------
comment&code: //TODO: should we allow suffixes on these ?return ( String[] ) subclassPropertyColumnNames.get( propertyName );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759147867560387
---------------------------------
comment&code: //TODO: is this really necessary????boolean[] includeOldField = entityMetamodel.getOptimisticLockStyle() == OptimisticLockStyle.ALL
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675925776362419
---------------------------------
comment&code: // TODO : not sure the best way to handle this. // The non-performant way :last();
true label: 1
predicted label: 0
non_satd_prob: 0.98324054479599 satd_prob: 0.0167594775557518
---------------------------------
comment&code: //TODO: is there a better way?return collectionName != null && !getPropertyType().isCollectionType();
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759147867560387
---------------------------------
comment&code: //The class is now way to complex!private int dotcount;
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758956015110016
---------------------------------
comment&code: // TODO : would be really nice to cache the spec on the query-def so as to not have to re-calc the hash; // currently not doable though because of the resultset-ref stuff...NativeSQLQuerySpecification spec;
true label: 1
predicted label: 0
non_satd_prob: 0.98324054479599 satd_prob: 0.016759462654590607
---------------------------------
comment&code: //name from a super query (a bit inelegant that it shows up here)}
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759099438786507
---------------------------------
comment&code: //put() has nowait semantics, is this really appropriate? //note that it needs to be async replication, never local or syncregion.put( space, ts );
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675925776362419
---------------------------------
comment&code: // ugly hack for cases like "elements(foo.bar.collection)" // (multi-part path expression ending in elements or indices)String[] tokens = StringHelper.split( ".", token, true );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759052872657776
---------------------------------
comment&code: //TODO: COPY/PASTE FROM SessionImpl, pull up!@Override
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759302467107773
---------------------------------
comment&code: //Must be done here because of side-effect! yuck...int scalarSize = scalarTypes.size();
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675906963646412
---------------------------------
comment&code: //We should actually rework this class to not implement Parser //and just process path expressions in the most convenient way.//The class is now way to complex!
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.0167593602091074
---------------------------------
comment&code: // we may be screwed here since the collection action is about to execute // and we do not know the final owner key valuereturn finalKey;
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675923354923725
---------------------------------
comment&code: // Needed the "clazz_" check to work around union-subclasses // TODO : is there a way to tell whether a persister is truly discrim-column based inheritence?if ( discrimColumnName != null && !"clazz_".equals( discrimColumnName ) ) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759131103754044
---------------------------------
comment&code: //TODO: reuse the PreLoadEventfinal PreLoadEvent preLoadEvent = new PreLoadEvent( session )
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759082674980164
---------------------------------
comment&code: // Need a better way to define the suffixes here...text = child.renderValueCollectionSelectFragment( nonscalarSize, nonscalarSize + k );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675904355943203
---------------------------------
comment&code: //workaround for WebLogicLOG.debug("could not log warnings", sqle);
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675894297659397
---------------------------------
comment&code: //TODO: temporaryfinal ComponentMetamodel metamodel = new ComponentMetamodel( this );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675916463136673
---------------------------------
comment&code: // TODO : YUCK!!!  fix after HHH-1907 is completereturn Environment.getBytecodeProvider().getProxyFactoryFactory().buildProxyFactory();
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675920933485031
---------------------------------
comment&code: // some messy, complex stuff here, since createCriteria() can take an // aliased path, or a path rooted at the creating criteria instanceCriteria parent = null;
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675916463136673
---------------------------------
comment&code: //TODO: add a CriteriaImplementor interface //      this class depends directly upon CriteriaImpl in the impl package...private final CriteriaQueryTranslator translator;
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759172081947327
---------------------------------
comment&code: // polymorphism not really handled completely correctly, // perhaps...well, actually its ok, assuming that the // entity name used in the lookup is the same as the // the one used here, which it will beEntityUniqueKey euk = new EntityUniqueKey(
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759250313043594
---------------------------------
comment&code: //This is not very nice (and quite slow):final String[][] cols = persister == rootPersister ?
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675897277891636
---------------------------------
comment&code: //TODO: get SQL rendering out of hereCollectionElement elem = new CollectionElement();
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759099438786507
---------------------------------
comment&code: // meant to handle dynamic instantiation queries...(Copy from QueryLoader)HolderInstantiator holderInstantiator = buildHolderInstantiator( resultTransformer );
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758887097239494
---------------------------------
comment&code: // Make sure this is a defined parameter and check the incoming value type // TODO: what should be the actual exception type here?Type type = definition.getParameterType( name );
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759267076849937
---------------------------------
comment&code: // worrying about proxies is perhaps a little bit of overkill here...if ( element instanceof HibernateProxy ) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759181395173073
---------------------------------
comment&code: // todo : throw exception?  maybe warn if not the same?}
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759250313043594
---------------------------------
comment&code: //TODO: make EntityPersister *not* depend on SessionFactoryImplementor //interface, if possible//NOTE: unlike all other Loaders, this one is NOT
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759367659687996
---------------------------------
comment&code: // TODO : what amount of significant digits need to be supported here? //      - from the DecimalFormat docs: //          [significant digits] = [minimum integer digits] + [maximum fraction digits]DecimalFormat jdkFormatter = new DecimalFormat( FORMAT_STRING );
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759328544139862
---------------------------------
comment&code: //for backward compatibility, allow a set with no not-null  //element columns, using all columns in the row locater SQL //TODO: create an implicit not null constraint on all cols?else {
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759274527430534
---------------------------------
comment&code: // TODO: copy/paste from ManyToOneTypepublic Serializable disassemble(Object value, SessionImplementor session, Object owner)
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759302467107773
---------------------------------
comment&code: //TODO: code duplication with SingleTableEntityPersisterArrayList columnTableNumbers = new ArrayList();
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759028658270836
---------------------------------
comment&code: // todo : throw exception?}
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759131103754044
---------------------------------
comment&code: //should this interface extend PropertyMapping?/**
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758903861045837
---------------------------------
comment&code: // TODO: here is why we need to make bytecode provider global :( // TODO : again, fix this after HHH-1907 is completeoptimizer = Environment.getBytecodeProvider().getReflectionOptimizer(
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.01675938256084919
---------------------------------
comment&code: //TODO: currently keeps Getters and Setters (instead of PropertyAccessors) because of the way getGetter() and getSetter() are implemented currently; yuck!private final EntityMetamodel entityMetamodel;
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759242862462997
---------------------------------
comment&code: //TODO: Yuck! This is not quite good enough, it's a quick //hack around the problem of having a to-one association //that refers to an embedded component:super.getReturnedClass().isInstance(parent);
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759352758526802
---------------------------------
comment&code: //TODO: implement caching?! proxies?!EntityUniqueKey euk = new EntityUniqueKey(
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759192571043968
---------------------------------
comment&code: // is this really necessary?ByteArrayOutputStream outputStream = new ByteArrayOutputStream(2048);
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675894297659397
---------------------------------
comment&code: //TODO: this is a little inefficient, don't need to do a whole //      deep replaceElements() callreplaceElements( result, target, owner, copyCache, session );
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759367659687996
---------------------------------
comment&code: //TODO: this is a bit arbitrary, expose a switch to the user?return "";
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759319230914116
---------------------------------
comment&code: "/**	 * @return collection removal	 * FIXME: even if isInverse=""true""?	 */"*         FIXME: even if isInverse="true"?
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759328544139862
---------------------------------
comment&code: // TODO: Fix this so it will work for non-POJO entity modeType keyType = getPersister( session ).getKeyType();
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759302467107773
---------------------------------
comment&code: //TODO: move these to a new JoinableType abstract class, //extended by EntityType and PersistentCollectionType:* Is the primary key of the owning entity table
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675911620259285
---------------------------------
comment&code: //SPACES //TODO: i'm not sure, but perhaps we should exclude //      abstract denormalized tables?int spacesSize = 1 + persistentClass.getSynchronizedTables().size();
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759267076849937
---------------------------------
comment&code: //TODO: is there a more elegant way than downcasting?AbstractQueryImpl query = (AbstractQueryImpl) session.getNamedSQLQuery(queryName);
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675918512046337
---------------------------------
comment&code: //TODO: remove use of instanceof!Component component = (Component) prop.getValue();
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759147867560387
---------------------------------
comment&code: //TODO: perhaps this should be some other RuntimeException...throw new HibernateException( "illegally attempted to associate a proxy with two open Sessions" );
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759399324655533
---------------------------------
comment&code: //Yuck:if ( inFromClause
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675892062485218
---------------------------------
comment&code: //TODO: design new lifecycle for ProxyFactorypf.postInstantiate(
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675923354923725
---------------------------------
comment&code: // todo: we should really just collect these from the various SelectExpressions, rather than regenerating herecolumnNames = getSessionFactoryHelper().generateColumnNames( queryReturnTypes );
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675925776362419
---------------------------------
comment&code: // TODO: Should this really return null?  If not, figure out something better to do here.}
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759390011429787
---------------------------------
comment&code: // TODO : this really needs to be delayed unitl after we definitively know all node types // where this is currently a problem is parameters for which where we cannot unequivocally // resolve an expected typeSessionFactoryImplementor sessionFactory = getSessionFactoryHelper().getFactory();
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.01675931178033352
---------------------------------
comment&code: // create an index on the key columns??}
true label: 1
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: //init the table here instead of earlier, so that we can get a quoted table name //TODO: would it be better to simply pass the qualified table name, instead of //      splitting it up into schema/catalog/table namesString tableName = getTable().getQuotedName(dialect);
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675928197801113
---------------------------------
comment&code: // NOTE: this assumes something about how propertySelectFragment is implemented by the subclass! // was toUnqotedAliasStrings( getdiscriminatorColumnName() ) before - now tried // to remove that unqoting and missing aliases..// was toUnqotedAliasStrings( getIdentiferColumnNames() ) before - now tried
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675918512046337
---------------------------------
comment&code: // Put a placeholder in entries, so we don't recurse back and try to save() the // same object again. QUESTION: should this be done before onSave() is called? // likewise, should it be done before onUpdate()?source.getPersistenceContext().addEntry(
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675928197801113
---------------------------------
comment&code: //before cascade! //TODO: should this be Session.instantiate(Persister, ...)?copyCache.put( original, copy );
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759226098656654
---------------------------------
comment&code: //TODO: we should throw an exception if we really *know* for sure   //      that this is a detached instance, rather than just assuming //throw new StaleObjectStateException(entityName, id);propertyName
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759352758526802
---------------------------------
comment&code: //TODO: if object was an uninitialized proxy, this is inefficient, //      resulting in two SQL selectsEntityEntry entry = source.getPersistenceContext().getEntry(entity);
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759099438786507
---------------------------------
comment&code: //TODO: put this stuff back in to read snapshot from //      the second-level cache (needs some extra work)/*Object[] cachedState = null;
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759274527430534
---------------------------------
comment&code: //this is kinda the best we can do...if ( object instanceof HibernateProxy ) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759052872657776
---------------------------------
comment&code: /* trim done to workaround stupid oracle bug that cant handle whitespaces before a { in a sp */cacheable,
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759099438786507
---------------------------------
comment&code: //TODO: this needn't exclude subclasses...LinkedHashSet<EntityKey> set =  batchLoadableEntityKeys.get( persister.getEntityName() );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759082674980164
---------------------------------
comment&code: //TODO: we use two visitors here, inefficient!OnReplicateVisitor visitor = new OnReplicateVisitor( source, id, entity, false );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759181395173073
---------------------------------
comment&code: //TODO: does this really need to be here? //      does the collection already have //      it's own up-to-date snapshot?return collection.wasInitialized() &&
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759399324655533
---------------------------------
comment&code: // TODO: an alternative is to check if the owner has changed; if it hasn't then // return collection.getOwner()Serializable entityId = getLoadedCollectionOwnerIdOrNull( ce );
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759274527430534
---------------------------------
comment&code: //I suppose?}
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758838668465614
---------------------------------
comment&code: "// TBD should this be varbinary($1)? //		registerColumnType(Types.VARBINARY,     ""binary($1)"");"//		registerColumnType(Types.VARBINARY,     "binary($1)");
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675894297659397
---------------------------------
comment&code: //shortcut}
true label: 1
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675872877240181
---------------------------------
comment&code: // todo : should we additionally check the current isolation mode explicitly?SessionFactoryImplementor factory = session.getFactory();
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675918512046337
---------------------------------
comment&code: // todo : is there really any reason to kkeep trying if this fails once?oracleCursorTypeSqlType = extractOracleCursorTypeValue();
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759181395173073
---------------------------------
comment&code: // TODO : not sure this is correct, could not find docs on how to do this.return "{?= call current_timestamp}";
true label: 1
predicted label: 0
non_satd_prob: 0.98324054479599 satd_prob: 0.016759516671299934
---------------------------------
comment&code: //HSQL has no Blob/Clob support .... but just put these here for now!if ( hsqldbVersion < 20 ) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675911620259285
---------------------------------
comment&code: "// merges don't cascade to uninitialized collections //			//TODO: perhaps this does need to cascade after all...."return getLoadedElementsIterator(session, collectionType, collection);
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759274527430534
---------------------------------
comment&code: // yick!  need this for proper serialization/deserialization handling...wrapper.setWrapped( wrapped );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759052872657776
---------------------------------
comment&code: //TODO: should orphans really be deleted during lock???return false;
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759319230914116
---------------------------------
comment&code: // todo : move to StringHelper?if ( stringForm != null ) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759006306529045
---------------------------------
comment&code: // Sets can be just a view of a part of another collection. // do we need to copy it to be sure it won't be changing // underneath us? // ie. this.set.addAll(set);this.set = set;
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759242862462997
---------------------------------
comment&code: // TODO: It would be really, really nice to use this to also model components!/**
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759352758526802
---------------------------------
comment&code: //TODO: move to .sql package!!buf.append("select ");
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759077087044716
---------------------------------
comment&code: //TODO: look at the owning property and check that it  //      isn't lazy (by instrumentation)EntityType entityType =(EntityType) type;
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675916463136673
---------------------------------
comment&code: // TODO : add this info to the translator and aggregate it here...return null;
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759390011429787
---------------------------------
comment&code: // would be better to use the element-type to determine // whether the old and the new are equal here; the problem being // we do not necessarily have access to the element type in all // casesif ( value != old ) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759302467107773
---------------------------------
comment&code: //TODO: code duplication with JoinedSubclassEntityPersisterArrayList columnJoinNumbers = new ArrayList();
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759028658270836
---------------------------------
comment&code: //TODO: refactor to .sql packageprivate CollectionSubqueryFactory() {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759099438786507
---------------------------------
comment&code: //TODO: *two* hashmap lookups here is one too many...String[] columns = (String[]) columnsByPropertyPath.get(propertyName);
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759123653173447
---------------------------------
comment&code: //note that this method could easily be moved up to BasicEntityPersister, //if we ever needed to reuse it from other subclasses//figure out which tables need to be fetched
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759274527430534
---------------------------------
comment&code: // from the collection of associations, locate OJA for the // ManyToOne corresponding to this persister to fully // define the many-to-many; we need that OJA so that we can // use its alias here // TODO : is there a better way here?Iterator itr = associations.iterator();
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759289428591728
---------------------------------
comment&code: //TODO: this class depends directly upon CriteriaImpl,  //      in the impl package ... add a CriteriaImplementor  //      interface//NOTE: unlike all other Loaders, this one is NOT
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.01675931178033352
---------------------------------
comment&code: // Do we need to qualify index names with the schema name?return false;
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759099438786507
---------------------------------
comment&code: //TODO: We probably should have a StatisticsNotPublishedException, to make it cleanSessionFactory sf;
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.01675931178033352
---------------------------------
comment&code: // NOTE VERY HACKISH WORKAROUND!! // TODO: Fix this so it will work for non-POJO entity modeType keyType = getPersister( session ).getKeyType();
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759390011429787
---------------------------------
comment&code: //TODO: need to make the majority of this functionality into a top-level support class for custom impl support/**
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759352758526802
---------------------------------
comment&code: //TODO: inefficient if that cache is just going to ignore the updated state!CacheEntry ce = persister.buildCacheEntry( instance,state, nextVersion, getSession() );
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759226098656654
---------------------------------
comment&code: // TODO: an alternative is to check if the owner has changed; if it hasn't then // get the ID from collection.getOwner()// return collection.getOwner()
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675928197801113
---------------------------------
comment&code: //TODO:refactor + make this method privatearrayHolders.put( holder.getValue(), holder );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759099438786507
---------------------------------
comment&code: // todo : temporary //      needed because currently persister is the one that //      creates and renders the join fragments for inheritence //      hierarchies...// creates and renders the join fragments for inheritance
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675909198820591
---------------------------------
comment&code: //swaldman 2004-02-07: modify to allow null values to signify fall through to c3p0 PoolConfig defaultsInteger minPoolSize = ConfigurationHelper.getInteger( Environment.C3P0_MIN_SIZE, props );
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675894297659397
---------------------------------
comment&code: // work around that crazy issue where the tree contains // "empty" FromElements (no text); afaict, this is caused // by FromElementFactory.createCollectionJoin()if ( fromElement.getOrigin() == null ) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675902120769024
---------------------------------
comment&code: //TODO: move to .sql package, and refactor with similar things!return StringHelper.join( "=? and ",
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759296879172325
---------------------------------
comment&code: //TODO: I am not so sure about the exception handling in this bit!sequentialSelect = session.getTransactionCoordinator()
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759328544139862
---------------------------------
comment&code: //ugly little workaround for fact that createUniqueKeyLoaders() does not handle component propertiesif ( useStaticLoader ) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759036108851433
---------------------------------
comment&code: // append the SQL to return the generated identifier //TODO: suck into Insertif ( j == 0 && identityInsert && useInsertSelectIdentity() ) { //TODO: suck into Insert
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759192571043968
---------------------------------
comment&code: //This is really ugly, but necessary:/**
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759131103754044
---------------------------------
comment&code: // todo : modify the class definition if not already transformed...byte[] b = cc.toBytecode();
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675894297659397
---------------------------------
comment&code: //TODO: should we use SELECT .. FOR UPDATE?Select select = new Select( getFactory().getDialect() );
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675925776362419
---------------------------------
comment&code: //TODO: is this 100% correct?getSession().getPersistenceContext().getCollectionsByKey().remove(
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759147867560387
---------------------------------
comment&code: // NOTE: this assumes something about how propertySelectFragment is implemented by the subclass! // was toUnqotedAliasStrings( getIdentiferColumnNames() ) before - now tried // to remove that unqoting and missing aliases..return new Alias( suffix ).toAliasStrings( getIdentifierAliases() );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675914041697979
---------------------------------
comment&code: //TODO: move into collection type, so we can use polymorphism!if ( collectionType.hasHolder() ) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759274527430534
---------------------------------
comment&code: // TODO should we just collect these like with the collections above?sqlAliasSuffixes[i] = ( size == 1 ) ? "" : Integer.toString( i ) + "_";
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759296879172325
---------------------------------
comment&code: //hum ... should we cascade anyway? throw an exception? fine like it is?return;
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759242862462997
---------------------------------
comment&code: //TODO: copy/paste from insertRows()int loc = writeKey( st, id, offset, session );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759123653173447
---------------------------------
comment&code: //TODO: suck into event class}
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675918512046337
---------------------------------
comment&code: // xmlforest requires a new kind of function constructorregisterFunction( "year", new StandardJDBCEscapeFunction( "year", StandardBasicTypes.INTEGER ) );
true label: 1
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758911311626434
---------------------------------
comment&code: // TODO Is this a valid operation on a timestamps cache?Transaction tx = suspend();
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759302467107773
---------------------------------
comment&code: //need to do that here rather than in the save event listener to let //the post insert events to have a id-filled entity when IDENTITY is used (EJB3)persister.setIdentifier( instance, generatedId, session );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675914041697979
---------------------------------
comment&code: // TODO : safe to interpret "map.remove(key) == null" as non-dirty?initialize( true );
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759319230914116
---------------------------------
comment&code: // TODO: Replace this with a more elegant solution.String[] idColumnNames = ( persister != null ) ?
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675928197801113
---------------------------------
comment&code: // short cut check...if ( !Character.isLetter( chars[0] ) ) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675875298678875
---------------------------------
comment&code: // this is ugly here, but needed because its a subqueryq.addQuerySpaces( q.getCollectionPersister( pathExpressionParser.getCollectionRole() ).getCollectionSpaces() );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675911620259285
---------------------------------
comment&code: // TODO : will need reference to session factory to fully complete HHH-1907//	private final SessionFactoryImplementor sessionFactory;
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.0167593602091074
---------------------------------
comment&code: // inheritance cycle detection (paranoid check)PersistentClass superclass = getSuperclass();
true label: 1
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675880141556263
---------------------------------
comment&code: // TODO: encapsulate the protected instance variables!private final String role;
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759226098656654
---------------------------------
comment&code: //polymorphism comment aboveukName,
true label: 1
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: // TODO: handle TypeDefsAttribute typeNode = node.attribute( "type" );
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675918512046337
---------------------------------
comment&code: //TODO: get all properties, not just the fetched ones!metadata.getServiceRegistry()
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675916463136673
---------------------------------
comment&code: //TODO: native idsSerializable id = persister.getIdentifierGenerator().generate( getSession(), entry );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759106889367104
---------------------------------
comment&code: // TODO: bindpropertyresults(alias, returnElem)lockMode
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675925776362419
---------------------------------
comment&code: //TODO: handle property-refreturn "? " +
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759077087044716
---------------------------------
comment&code: //TODO: validate existing of property with the chosen name. (secondpass )ArrayList allResultColumns = getResultColumns(propertyresult);
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675906963646412
---------------------------------
comment&code: //TODO: check that entry.getIdentifier().equals(requestedId).getColumnIterator() );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759106889367104
---------------------------------
comment&code: // TODO: RESTRICT VIOLATIONcase 23001: return null;
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.01675940677523613
---------------------------------
comment&code: //TODO: assertion only, could be optimized awaythrow new AssertionFailure( "entity was persistent" );
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675925776362419
---------------------------------
comment&code: //TODO: optimize away this lookup for entities w/o unsaved-value="undefined"final EntityKey entityKey = session.generateEntityKey( id, persister );
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675918512046337
---------------------------------
comment&code: //TODO: arithmetic expressions, multiple new Foo(...)private static final Set COUNT_MODIFIERS = new HashSet();
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675914041697979
---------------------------------
comment&code: // TODO: not visible to the user!}
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759274527430534
---------------------------------
comment&code: //TODO: proxies!if ( me.getValue()==element ) return me.getKey();
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759082674980164
---------------------------------
comment&code: //TODO: can we limit stored procedures ?!col += limitHandler.bindLimitParametersAtStartOfQuery( st, col );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675911620259285
---------------------------------
comment&code: //TODO: formulas ?public void initCollectionPropertyMap() {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758982092142105
---------------------------------
comment&code: // TODO: better error message since we actually support composites if names are explicitly listed.throw new QueryException(
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759367659687996
---------------------------------
comment&code: //TODO: use these in methods abovepublic String getEntityName(Criteria subcriteria, String propertyName) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675914041697979
---------------------------------
comment&code: //TODO: cache the persister, this shows up in yourkitfinal Serializable id = session.getEntityPersister( entityName, obj ).getIdentifier( obj, session );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759172081947327
---------------------------------
comment&code: //TODO: add referencedClass to disambiguate to FKs on the same //      columns, pointing to different tablesfk.setTable( this );
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759226098656654
---------------------------------
comment&code: //TODO: create uk loaders for component properties}
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759060323238373
---------------------------------
comment&code: //TODO: terrible implementation!return value == null
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759192571043968
---------------------------------
comment&code: //TODO: eventually put this back in, once we think all is fixed //Object otherAlias = columnsUnique.put(qualifiedColumn, columnAlias);/*if ( otherAlias!=null && !columnAlias.equals(otherAlias) ) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759157180786133
---------------------------------
comment&code: // TODO: I don't really like this implementation; it would be better if // this was handled by searchForDirtyCollections()return isOwnerVersioned( session ) && super.isDirty( old, current, session );
true label: 1
predicted label: 0
non_satd_prob: 0.98324054479599 satd_prob: 0.016759462654590607
---------------------------------
comment&code: // TODO: check if key contains the owner ID}
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759242862462997
---------------------------------
comment&code: //TODO: cache this in an instvarreturn getFactory().getDialect().getIdentitySelectString(
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759106889367104
---------------------------------
comment&code: // TODO : temporary initial step towards HHH-1907final ComponentMetamodel metamodel = new ComponentMetamodel( this );
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759274527430534
---------------------------------
comment&code: // todo : remove this once ComponentMetamodel is complete and mergedpublic Getter getGetter(Class clazz) throws PropertyNotFoundException, MappingException {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675902120769024
---------------------------------
comment&code: //TODO: add owner argument!!throws HibernateException;
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759181395173073
---------------------------------
comment&code: //TODO: for some dialects it would be appropriate to add the renderOrderByPropertiesSelect() to other select stringsmergeJoins( sql.getJoinFragment() );
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675918512046337
---------------------------------
comment&code: //TODO: unnecessary for databases with ANSI-style joinsDisjunctionFragment df = new DisjunctionFragment();
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675918512046337
---------------------------------
comment&code: //TODO: maybe call it getRowSelection() ?public RowSelection getSelection() {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759131103754044
---------------------------------
comment&code: //TODO: make this handle multiple collection roles!final CollectionPersister[] collectionPersisters = getCollectionPersisters();
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759099438786507
---------------------------------
comment&code: //TODO: include the rowids!!!!if ( hasSubclasses() ) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759131103754044
---------------------------------
comment&code: // TODO : or should we return 'containsTableAlias'??LOG.tracev( "Forcing inclusion of extra joins [alias={0}, containsTableAlias={1}]", alias, containsTableAlias );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759147867560387
---------------------------------
comment&code: /////////////////////////////////////////////////////////////////////// // TODO : look at perhaps caching this...// as a control measure, now update the node while it is detached and
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759399324655533
---------------------------------
comment&code: //TODO: avoid this for non-new instances where mightBeDirty==falseboolean substitute = wrapCollections( session, persister, types, values);
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675925776362419
---------------------------------
comment&code: // todo : look at optimizing these...oos.writeObject( loadQueryInfluencers );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759052872657776
---------------------------------
comment&code: // todo : cache this sql...String versionIncrementString = generateVersionIncrementUpdateString();
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675897277891636
---------------------------------
comment&code: "/**	 * TODO: Check if Mimer SQL cannot handle the way DB2 does	 */"public boolean supportsIdentityColumns() {
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759328544139862
---------------------------------
comment&code: //TODO: if we are using identity columns, fetch the identifier}
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675911620259285
---------------------------------
comment&code: //TODO check there is no actual definition elemnents when a ref is defined}
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675904355943203
---------------------------------
comment&code: // table=null -> an association // - fill it in later //TODO fill in the mappings for table == nullmappings.addColumnBinding( logicalColumnName, column, table );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675902120769024
---------------------------------
comment&code: // table=null -> an association - fill // it in later //TODO fill in the mappings for table == nullmappings.addColumnBinding( logicalColumnName, column, table );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675902120769024
---------------------------------
comment&code: // TODO : why aren't these the same?if ( lhs.getImpliedJoin() != null || lhs.getFromElement().isImplied() ) {
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759274527430534
---------------------------------
comment&code: //TODO: if we support multiple fetch groups, we would need //      to clone the set of lazy properties!FieldInterceptionHelper.injectFieldInterceptor( entity, getEntityName(), lazyProps, session );
true label: 1
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759201884269714
---------------------------------
comment&code: //TODO mappings.getLogicalTableName(ownerTable)String logicalOwnerTableName = ownerTable.getName();
true label: 1
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675897277891636
---------------------------------
comment&code: //TODO: always true for now, but not if we later decide to support elements() in the from clauseinElementsFunction = true;
true label: 1
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.01675931178033352
---------------------------------
comment&code: // we could move this inside if we wanted to // tolerate collection initializations during // collection dirty checking:prepareCollectionFlushes( persistenceContext );
true label: 1
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759099438786507
---------------------------------
comment&code: //root entity comes *last*resultTypeList.add( translator.getResultType( criteria ) );
true label: 0
predicted label: 0
non_satd_prob: 0.9832413196563721 satd_prob: 0.01675872504711151
---------------------------------
comment&code: //==elementType ??else {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758769750595093
---------------------------------
comment&code: //scan the query string for class names appearing in the from clause and replace //with all persistent implementors of the class/interface, returning multiple //query strings (make sure we don't pick up a class in the select clause!)//TODO: this is one of the ugliest and most fragile pieces of code in Hibernate....
true label: 0
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759296879172325
---------------------------------
comment&code: //identifier collections not supported for 1-to-manyif ( getFactory().getSettings().isCommentsEnabled() ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: // potentialTrimCharacterArgIndex = 1 assumes that a // trim-specification has been specified.  we handle the // exception to that explicitlyint potentialTrimCharacterArgIndex = 1;
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758989542722702
---------------------------------
comment&code: // Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~// seems to not really...
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759013757109642
---------------------------------
comment&code: // if the current depth is 0, the root thing being loaded is the // many-to-many collection itself.  Here, it is alright to use // an inner join...list = s.createQuery( "from Human h inner join h.friends as f with f.nickName like 'bubba'" )
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759060323238373
---------------------------------
comment&code: // update removed rows fks to nulltry {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758818179368973
---------------------------------
comment&code: //registerFunction( "trim", new StandardSQLFunction( "trim", Hibernate.STRING ) );"midnight_seconds",
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675877720117569
---------------------------------
comment&code: "//			buf.append( selectFragment( lhsAlias, """" ) )//ignore suffix for collection columns!"replace(
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758769750595093
---------------------------------
comment&code: // initialize the Set of queried identifier spaces (ie. tables)Iterator iter = collections.values().iterator();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: //use suffix for the entity columns.toString();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758760437369347
---------------------------------
comment&code: // we got here because we assumed that an instance // with an assigned id was detached, when it was // really persistententityIsTransient(event, copyCache);
true label: 0
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675925776362419
---------------------------------
comment&code: // the class hierarchy structureprivate final String subquery;
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758760437369347
---------------------------------
comment&code: // remove the current element from insertions. It will be added back later.String entityName = action.getEntityName();
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758903861045837
---------------------------------
comment&code: //private final String rootTableName;private final String[] subclassClosure;
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758736222982407
---------------------------------
comment&code: //INITIALIZATION:public UnionSubclassEntityPersister(
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: //not null ... (start with 1) is implicit}
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675880141556263
---------------------------------
comment&code: // continue loop}
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675875298678875
---------------------------------
comment&code: // return existing object or initialized proxy (unless deleted)LOG.trace( "Entity found in session cache" );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675882562994957
---------------------------------
comment&code: // the list of entity names that indicate the batch numberfor ( EntityInsertAction action : (List<EntityInsertAction>) insertions ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758818179368973
---------------------------------
comment&code: //disassembled state gets put in a new array (we write to cache by value!)this.disassembledState = TypeHelper.disassemble(
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758956015110016
---------------------------------
comment&code: // Execute the SQL:public String fromTableFragment(String name) {
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675884611904621
---------------------------------
comment&code: //sort the updates by fkjava.util.Collections.sort( collectionCreations );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675882562994957
---------------------------------
comment&code: // This could also just be true all the time...return isAbstract() || hasSubclasses();
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759036108851433
---------------------------------
comment&code: // the mapping of entity names to their latest batch numbers.private HashMap<String,Integer> latestBatches = new HashMap<String,Integer>();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675877720117569
---------------------------------
comment&code: //chop the last union (all)buf.setLength( buf.length() - ( dialect.supportsUnionAll() ? 11 : 7 ) );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675875298678875
---------------------------------
comment&code: // note that for sequential scrolling, we make the assumption that // the first persister element is the "root entity"if ( resultSet.isAfterLast() ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675897277891636
---------------------------------
comment&code: //TODO: check this....return getTableName();
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759131103754044
---------------------------------
comment&code: // 23000: Check constraint violation: {0} // 23001: Unique index or primary key violation: {0}if ( sqle.getSQLState().startsWith( "23" ) ) {
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758887097239494
---------------------------------
comment&code: // the closure of all properties in the entire hierarchy including // subclasses and superclasses of this classprivate final int[] subclassPropertyTableNumberClosure;
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675884611904621
---------------------------------
comment&code: //expressionTerminators.add(","); // deliberately excludedEXPRESSION_OPENERS.add( "and" );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: // subclass discrimination works by assigning particular // values to certain combinations of null primary key // values in the outer join using an SQL CASEprivate final Map subclassesByDiscriminatorValue = new HashMap();
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758950427174568
---------------------------------
comment&code: // Multi-param numeric dialect functions...registerFunction( "atan2", new StandardSQLFunction("atan2", StandardBasicTypes.FLOAT) );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758793964982033
---------------------------------
comment&code: // Use theta style (for regression) // Move the node up, after the origin node.FromElement origin = fromElement.getOrigin();
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758862882852554
---------------------------------
comment&code: // Multi-param date dialect functions...registerFunction( "add_months", new StandardSQLFunction("add_months", StandardBasicTypes.DATE) );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758760437369347
---------------------------------
comment&code: // SQLException support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/**
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758769750595093
---------------------------------
comment&code: // This assumes you will want to ignore any update countswhile ( !isResultSet && ps.getUpdateCount() != -1 ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675897277891636
---------------------------------
comment&code: //skip the FROM keyword in params/**
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: // Custom sqlfinal AnnotationInstance sqlLoaderAnnotation = JandexHelper.getSingleAnnotation(
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675877720117569
---------------------------------
comment&code: // return a newly loaded objectreturn load(event, persister, keyToLoad, options);
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: // make it circular-reference safefinal EntityKey entityKey = session.generateEntityKey( entityId, subclassPersister );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675882562994957
---------------------------------
comment&code: //Cope with special cases of AND, NOT, ()specialCasesBefore( lcToken );
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758911311626434
---------------------------------
comment&code: // subclass closure properties//TODO: code duplication with SingleTableEntityPersister
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759082674980164
---------------------------------
comment&code: // for dialects which are known to not support ANSI-SQL row-value-constructor syntax, // we should mutate the tree.if ( !sessionFactory.getDialect().supportsRowValueConstructorSyntax() ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675897277891636
---------------------------------
comment&code: // we have the form: trim(from trimSource). //      This is functionally equivalent to trim(trimSource) // EARLY EXIT!!!!return Arrays.asList( naturalIdLoadAccess.load() );
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759013757109642
---------------------------------
comment&code: // SUBCLASSESsubclassByDiscriminatorValue.put(
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758769750595093
---------------------------------
comment&code: //need to hydrate it.// grab its state from the ResultSet and keep it in the Session
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675897277891636
---------------------------------
comment&code: //starts with 1, implicitly}
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675877720117569
---------------------------------
comment&code: // instantiate a new instanceobject = session.instantiate( instanceClass, key.getIdentifier() );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675880141556263
---------------------------------
comment&code: // simple nullability constraintreturn null;
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758745536208153
---------------------------------
comment&code: //we need to upgrade the lock mode to the mode requestedsession.getPersistenceContext().getEntry(object)
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758956015110016
---------------------------------
comment&code: "//	register the type of the out param - an Oracle specific type"statement.registerOutParameter(col, oracletypes_cursor_value);
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: // look for a proxyObject proxy = persistenceContext.getProxy(keyToLoad);
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: // features which change between 8i, 9i, and 10g ~~~~~~~~~~~~~~~~~~~~~~~~~~/**
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758903861045837
---------------------------------
comment&code: // evicts don't cascade to uninitialized collectionsreturn getLoadedElementsIterator(session, collectionType, collection);
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758928075432777
---------------------------------
comment&code: // features which remain constant across 8i, 9i, and 10g ~~~~~~~~~~~~~~~~~~@Override
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758879646658897
---------------------------------
comment&code: // need to treat this as if it where optimistic-lock="all" (dirty does *not* make sense); // first we need to locate the "loaded" state // // Note, it potentially could be a proxy, so perform the location the safe way...// Note, it potentially could be a proxy, so doAfterTransactionCompletion the location the safe way...
true label: 0
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.01675931178033352
---------------------------------
comment&code: //( (Column) sc.getTable().getPrimaryKey().getColumnIterator().next() ).getName();value.addColumn( new Column( columnName ) );
true label: 0
predicted label: 0
non_satd_prob: 0.9832413196563721 satd_prob: 0.016758674755692482
---------------------------------
comment&code: // might happen with a managed connection}
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675894297659397
---------------------------------
comment&code: // don't need subclass tables, because they can't appear in conditions}
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675911620259285
---------------------------------
comment&code: // not final-static to avoid possible classcast exceptions if using different oracle drivers.int oracletypes_cursor_value = 0;
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675889641046524
---------------------------------
comment&code: //private List aliases = new ArrayList();private List columnAliases = new ArrayList();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675872877240181
---------------------------------
comment&code: // The reason for this is SQL doesn't let you sort by an expression you are // not returning in the result set.private final PathExpressionParser pathExpressionParser;
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675904355943203
---------------------------------
comment&code: //update all the modified entriesint count = doUpdateRows( id, collection, session );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: // special case where we need to force incloude all subclass joinsq.addSelectScalar( getFunction( "count", q ).getReturnType( StandardBasicTypes.LONG, q.getFactory() ) );
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758982092142105
---------------------------------
comment&code: // we did not find a collection element in the result set, so we // ensure that a collection is created with the owner's identifier, // since what we have is an empty collectionp.getIdentifierType(),
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759147867560387
---------------------------------
comment&code: //getDefaultProperties().setProperty(Environment.STATEMENT_BATCH_SIZE, NO_BATCH);public String getAddColumnString() {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758769750595093
---------------------------------
comment&code: // assumes that types are all of span 1Iterator iter = namedParams.entrySet().iterator();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675882562994957
---------------------------------
comment&code: // hibernate impelemnts cast in Dialect.javaregisterFunction( "ceiling", new StandardSQLFunction( "ceiling", StandardBasicTypes.INTEGER ) );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: // this is the root (versioned) table, and we are using version-based // optimistic locking;  if we are not updating the version, also don't // check it (unless this is a "generated" version column)!if ( checkVersion( includeProperty ) ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759147867560387
---------------------------------
comment&code: // aggregate functions shouldn't be registered, right? //registerFunction( "list", new StandardSQLFunction("list",Hibernate.STRING) ); // stopped on $list"midnight_seconds",
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759052872657776
---------------------------------
comment&code: //its the given optional objectobject = optionalObject;
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758769750595093
---------------------------------
comment&code: //decide which ResultSet to get the property value from:final boolean propertyIsDeferred = hasDeferred &&
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675889641046524
---------------------------------
comment&code: // properties of this class, including inherited propertiespublic String getAuthoriser() {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: // otherwise assume the parent is the the criteria that created usparent = subcriteria.getParent();
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758855432271957
---------------------------------
comment&code: // the closure of all columns used by the entire hierarchy including // subclasses and superclasses of this classprivate final int[] subclassPropertyTableNumberClosure;
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675887033343315
---------------------------------
comment&code: // we can go straight to the first required rowrs.absolute( firstRow );
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675889641046524
---------------------------------
comment&code: // now look up the object we are really interested in! // (this lets us correctly handle proxies and multi-row // or multi-column queries)// (this lets us correctly handle proxies and multi-row or multi-column queries)
true label: 0
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675918512046337
---------------------------------
comment&code: // discriminator columnif ( discriminatorColumnAnnotation != null ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832413196563721 satd_prob: 0.016758708283305168
---------------------------------
comment&code: // Code to handle subclasses of topClassObject discriminatorValue = persister.getDiscriminatorType().nullSafeGet(
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758838668465614
---------------------------------
comment&code: //NONE, because its the requested lock mode, not the actual!defaultLockModes = ArrayHelper.fillArray( LockMode.NONE, size );
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758928075432777
---------------------------------
comment&code: //private final Map propertyTableNumbersByName = new HashMap();private final Map propertyTableNumbersByNameAndSubclass = new HashMap();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675875298678875
---------------------------------
comment&code: // conceivable that the dialect ctor could throw HibernateExceptions, so don't re-wrapthrow e;
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759099438786507
---------------------------------
comment&code: // CLASS + TABLEjoinSpan = persistentClass.getJoinClosureSpan()+1;
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758769750595093
---------------------------------
comment&code: // synchronized to avoid multi-thread access issues; defined as method synch to avoid // potential deadlock issues due to nature of code.if ( session.getFactory().getSettings().isWrapResultSetsEnabled() ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759028658270836
---------------------------------
comment&code: // required to exception table // iconst_0 // icode.addIconst( 0 );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675880141556263
---------------------------------
comment&code: // for now, just "re-flatten" the metamodel since this is temporary stuff anyway (HHH-1907)this.isKey = metamodel.isKey();
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675911620259285
---------------------------------
comment&code: // checkcast // cast the bean into a raw beancode.addCheckcast( this.targetBean.getName() );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758818179368973
---------------------------------
comment&code: // checkcast (case of primitive type) // invokevirtual (case of primitive type)code.addInvokevirtual( target_type_index, getterName, getter_desc );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675877720117569
---------------------------------
comment&code: /* | this | bean | args | i | raw bean | exception | */if ( setters.length > 0 ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832413196563721 satd_prob: 0.016758708283305168
---------------------------------
comment&code: // Get the first child to be considered.  Sub-classes may do this differently in order to skip nodes that // are not select expressions (e.g. DISTINCT).AST firstChild = getFirstSelectExpression();
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759052872657776
---------------------------------
comment&code: // new // BulkAccessorExceptioncode.addNew( BULKEXCEPTION_CLASS_NAME );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: //"as" is not in KEYWORDS&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675882562994957
---------------------------------
comment&code: // getfield // get field "$JAVASSIST_CALLBACK" defined alreadycode.addOpcode(Opcode.GETFIELD);
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675882562994957
---------------------------------
comment&code: // dup// same however.
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: // todo : move this to SF per HHH-3517; also see HHH-1907 and ComponentMetamodelfinal ComponentTuplizerFactory componentTuplizerFactory = new ComponentTuplizerFactory();
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759077087044716
---------------------------------
comment&code: // putfield // put field "$JAVASSIST_CALLBACK" defined alreadycode.addOpcode(Opcode.PUTFIELD);
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675880141556263
---------------------------------
comment&code: /* local variables | this | callback | */Bytecode code = new Bytecode(cp, 3, 3);
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758793964982033
---------------------------------
comment&code: // find the batch number associated with the current association, if any.Integer associationBatchNumber = entityBatchNumber.get( value );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758793964982033
---------------------------------
comment&code: // invokeinterfacecode.addInvokeinterface( target_type_index, getterName, getter_desc, 1 );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675875298678875
---------------------------------
comment&code: // we *always* assume an instance with a null // identifier or no identifier property is unsaved!if ( id == null ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758982092142105
---------------------------------
comment&code: // DDL support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/**
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: "// seems to not really... //	public boolean supportsRowValueConstructorSyntax() { //		return true; //	}"if (obj == null)
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759060323238373
---------------------------------
comment&code: // below is for Cache' that don't have str in 2007.1 there is str and we register str directlyregisterFunction( "str", new SQLFunctionTemplate( StandardBasicTypes.STRING, "cast(?1 as char varying)" ) );
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675902120769024
---------------------------------
comment&code: // temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~private final String[] propertyNames;
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: // byteif ( Byte.TYPE.equals( javaType ) ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758745536208153
---------------------------------
comment&code: // the column doesnt exist at all.StringBuilder alter = new StringBuilder( root.toString() )
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: // note that %string is deprecatedregisterFunction( "%string", new VarArgsSQLFunction( StandardBasicTypes.STRING, "%string(", ",", ")" ) );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758769750595093
---------------------------------
comment&code: //If the object is already loaded, return the loaded oneobject = session.getEntityUsingInterceptor( key );
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758862882852554
---------------------------------
comment&code: // create new lock that times out immediatelyLock newLock = new Lock( ts, uuid, nextLockId.getAndIncrement(), null );
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758855432271957
---------------------------------
comment&code: // we really could refresh the item if it // is not a lock, but it might be slower //return freshTimestamp < txTimestampBatchModeTransactionManager.getInstance().commit();
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759181395173073
---------------------------------
comment&code: // Due to the complexity in initializing the SelectClause, do not generate one here. // If it is not found; simply return null... // // Also, do not cache since it gets generated well after we are created.return ( SelectClause ) ASTUtil.findTypeInChildren( this, SqlTokenTypes.SELECT_CLAUSE );
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675914041697979
---------------------------------
comment&code: // DISCRIMINATORbindDiscriminatorProperty( table, entity, subnode, mappings );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // Pre-flushing section // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~// HQL test
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675887033343315
---------------------------------
comment&code: // %upper is deprecatedregisterFunction( "%upper", new StandardSQLFunction( "%upper" ) );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: // let this take precedence if defined, since it works for // assigned identifiersBoolean result = entityMetamodel.getVersionProperty()
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758965328335762
---------------------------------
comment&code: //throw new UnsupportedOperationException("Can't write to a readonly object");* Throws UnsupportedOperationException since this cache is read-only
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759028658270836
---------------------------------
comment&code: // the contract of EntityTuplizer.determineConcreteSubclassEntityName says that returning null // is an indication that the specified entity-name (this.getEntityName) should be used.return this;
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675897277891636
---------------------------------
comment&code: // The syntax used to add a foreign key constraint to a table.return new StringBuilder( 300 )
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675889641046524
---------------------------------
comment&code: "//note: it is conceptually possible that a UserType could map null to //	  a non-null value, so the following is arguable:"if ( isNullableTable( j ) && isAllNull( fields, j ) ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675916463136673
---------------------------------
comment&code: // note: interfaces is assumed to already contain HibernateProxy.classtry {
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758950427174568
---------------------------------
comment&code: // identifier-commalist.append( ") REFERENCES " )
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758769750595093
---------------------------------
comment&code: //assembled state gets put in a new array (we read from cache by value!)Object[] assembledProps = TypeHelper.assemble(
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758903861045837
---------------------------------
comment&code: // we do not have to worry about queued additions to uninitialized // collections, since they can only occur for inverse collections!Iterator elems = getElementsIterator( collection, session );
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675916463136673
---------------------------------
comment&code: // disassemble named parametersfinal Map<String,TypedValue> namedParameters;
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758769750595093
---------------------------------
comment&code: // remove all collections for the entity from the session-level cacheif ( persister.hasCollections() ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675882562994957
---------------------------------
comment&code: // invokeinterface // callback.write*(..)code.addInvokeinterface( target_type_index, getterName, getter_desc, 1 );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675875298678875
---------------------------------
comment&code: // moved up from AbstractEntityPersister ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~private final SessionFactoryImplementor factory;
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758862882852554
---------------------------------
comment&code: // JOINSIterator joinIter = persistentClass.getJoinClosureIterator();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758736222982407
---------------------------------
comment&code: // classes mentioned in extends not available - so put it in queueAttribute packageAttribute = hibernateMappingElement.attribute( "package" );
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758928075432777
---------------------------------
comment&code: //propertyTableNumbersByName.put( prop.getName(), join );propertyTableNumbersByNameAndSubclass.put(
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758769750595093
---------------------------------
comment&code: //Access cached SQLprotected boolean isDiscriminatorFormula() {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758760437369347
---------------------------------
comment&code: //figure out which tables need to be fetchedAbstractEntityPersister subclassPersister = (AbstractEntityPersister) persister;
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675894297659397
---------------------------------
comment&code: "//	private final List persisters = new ArrayList();"private final Map alias2Return = new HashMap();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758745536208153
---------------------------------
comment&code: //figure out which columns are neededArrayList columnNumbers = new ArrayList();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675877720117569
---------------------------------
comment&code: // it is possible for this method to be called during flush processing, // so make certain that we do not accidently initialize an uninitialized proxy// so make certain that we do not accidentally initialize an uninitialized proxy
true label: 0
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759319230914116
---------------------------------
comment&code: //figure out which formulas are neededArrayList formulaNumbers = new ArrayList();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758810728788376
---------------------------------
comment&code: //get em on the second pass!columnReaders = (String[]) columnReadersByPropertyPath.get(foreignKeyProperty);
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758745536208153
---------------------------------
comment&code: //render the SQLreturn renderSelect(
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758736222982407
---------------------------------
comment&code: // local cache, so we use synchronization@Override
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675889641046524
---------------------------------
comment&code: // SQL stringsprivate String sqlVersionSelectString;
true label: 0
predicted label: 0
non_satd_prob: 0.9832413196563721 satd_prob: 0.01675872504711151
---------------------------------
comment&code: // IDENTITY support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/**
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: //if there is no resulting row, return nullif ( !rs.next() ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675882562994957
---------------------------------
comment&code: // *load_1 // each typeaddTypeDependDataLoad(code, finfo.getDescriptor(), 1);
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: // unfortunately not really safe to normalize this // to 1 as an initial value like we do the others // because we would not be able to control this if // we are using a sequence...if (value.lt(1)) LOG.pooledOptimizerReportedInitialValue(value);
true label: 0
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675925776362419
---------------------------------
comment&code: // select topic, syntax from information_schema.help // where section like 'Function%' order by section, topic // // see also ->  http://www.h2database.com/html/functions.html// Numeric Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758903861045837
---------------------------------
comment&code: // The optional SQL string defined in the where attributeprivate final String sqlWhereString;
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: //pass this as an argument only to avoid double lookingSessionImplementor source) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675897277891636
---------------------------------
comment&code: // for version properties marked as being generated, make sure they are "always" // generated; aka, "insert" is invalid; this is dis-allowed by the DTD, // but just to make sure...if ( prop.getGeneration() == PropertyGeneration.INSERT ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759157180786133
---------------------------------
comment&code: //information about lazy properties of this classprivate final String[] lazyPropertyNames;
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: // If there are any scalars (non-entities) selected, render the select column aliases.renderScalarSelects( selectExpressions, fromClause );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: //information about all columns/formulas in class hierarchyprivate final String[] subclassColumnClosure;
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: // Inner classes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~public final class Subcriteria implements Criteria, Serializable {
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758879646658897
---------------------------------
comment&code: // ( (Column) discrim.getColumnIterator().next() ).setType(type);}
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758736222982407
---------------------------------
comment&code: // dynamic filters attached to the class-levelprivate final FilterHelper filterHelper;
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758769750595093
---------------------------------
comment&code: // the loaded owner will be set to null after the collection is removed, // so capture its value as the affected owner so it is accessible to // both pre- and post- eventsthis.affectedOwner = session.getPersistenceContext().getLoadedCollectionOwnerOrNull( collection );
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758928075432777
---------------------------------
comment&code: // temporary table support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/**
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: // CUSTOM SQLhandleCustomSQL( node, entity );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675877720117569
---------------------------------
comment&code: // cascade first, so that all unsaved objects get their // copy created before we actually copy //cascadeOnMerge(event, persister, entity, copyCache, Cascades.CASCADE_BEFORE_MERGE);super.cascadeBeforeSave(source, persister, entity, copyCache);
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758911311626434
---------------------------------
comment&code: // model.getKey().setType( new Type( model.getIdentifier() ) );.getColumnIterator() );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675872877240181
---------------------------------
comment&code: // The syntax used to add a column to a tablereturn " add column";
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758887097239494
---------------------------------
comment&code: // simple, because we can't have a one-to-one or a collection  // (or even a property-ref) in a composite-element:String[] aliasedLhsColumns = StringHelper.qualify(alias, lhsColumns);
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758950427174568
---------------------------------
comment&code: // Completely optional cascading drop clause.return "";
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675880141556263
---------------------------------
comment&code: // PROPERTIESIterator iter = node.elementIterator();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675875298678875
---------------------------------
comment&code: // IDENTIFIERidentifierColumnSpan = persistentClass.getIdentifier().getColumnSpan();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: // VERSIONbindVersioningProperty( table, subnode, mappings, name, entity, inheritedMetas );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: //operations which cascade as far as the collection also cascade to collection elements);
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758862882852554
---------------------------------
comment&code: //WHERE STRINGsqlWhereString = StringHelper.isNotEmpty( persistentClass.getWhere() ) ? "( " + persistentClass.getWhere() + ") " : null;
true label: 0
predicted label: 0
non_satd_prob: 0.9832413196563721 satd_prob: 0.01675872504711151
---------------------------------
comment&code: // The loop ensures atomicity of the // select + update even for no transaction // or read committed isolation levelstatementLogger.logStatement( query, FormatStyle.BASIC.getFormatter() );
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675889641046524
---------------------------------
comment&code: // SUBCLASS PROPERTY CLOSUREArrayList columns = new ArrayList();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758760437369347
---------------------------------
comment&code: //before add :-)formnos[l] = -1;
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758736222982407
---------------------------------
comment&code: // Handle any filters applied to the class levelfilterHelper = new FilterHelper( persistentClass.getFilters(), factory );
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758838668465614
---------------------------------
comment&code: // only one-to-one is lazy fetchedreturn null;
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758862882852554
---------------------------------
comment&code: // replicate does cascade to uninitialized collectionsreturn getLoadedElementsIterator(session, collectionType, collection);
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675887033343315
---------------------------------
comment&code: //note early exit here:return initializeLazyPropertiesFromCache( fieldName, entity, session, entry, cacheEntry );
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.0167589969933033
---------------------------------
comment&code: // NOTE: this assumes something about how propertySelectFragment is implemented by the subclass!// was toUnqotedAliasStrings( getIdentiferColumnNames() ) before - now tried
true label: 0
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759216785430908
---------------------------------
comment&code: //deliberately ignore return value!resolvedJoinType = getJoinType( nullable, currentDepth );
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758838668465614
---------------------------------
comment&code: //strip leading ", "setText( text );
true label: 0
predicted label: 0
non_satd_prob: 0.9832413196563721 satd_prob: 0.016758715733885765
---------------------------------
comment&code: // if the metadata allowed proxy creation and caller did not request forceful eager loading, // generate a proxyreturn persister.createProxy( id, this );
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759028658270836
---------------------------------
comment&code: // If this from element is a collection and the path is a collection property (maxIndex, etc.) then // generate a sub-query.// requiring a sub-query then generate a sub-query.
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758933663368225
---------------------------------
comment&code: //otherwise return the "hydrated" state (ie. associations are not resolved)Type[] types = getPropertyTypes();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: // The name of the SQL function that transforms a string to lowercasereturn "lower";
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758933663368225
---------------------------------
comment&code: //null owner ok??}
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: // automatically makes a column with the default name if none is specifed by XMLpublic static void bindSimpleValue(Element node, SimpleValue simpleValue, boolean isNullable,
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758950427174568
---------------------------------
comment&code: // just ignore}
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758769750595093
---------------------------------
comment&code: // this is the exception returned by ReflectHelper.getConstructor() if it cannot // locate an appropriate constructorthrow new DetailedSemanticException( "Unable to locate appropriate constructor on class [" + className + "]", e );
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675902120769024
---------------------------------
comment&code: // ok in normal Hibernate usage to delete a detached entity; JPA however // forbids it, thus this is a hook for HEM to affect this behavior* We encountered a delete request on a transient instance.
true label: 0
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759226098656654
---------------------------------
comment&code: // null sql means that the only lazy properties // are shared PK one-to-one associations which are // handled differently in the Type#nullSafeGet code...ps = session.getTransactionCoordinator()
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759006306529045
---------------------------------
comment&code: // if the property mapping consists of all formulas,  // make it non-updateablereturn updateable && !ArrayHelper.isAllFalse( value.getColumnUpdateability() );
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758855432271957
---------------------------------
comment&code: // the user specifically supplied insert="true", // which constitutes an illegal combothrow new MappingException(
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758933663368225
---------------------------------
comment&code: // if the property mapping consists of all formulas,  // make it insertable// make it non-updateable
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758933663368225
---------------------------------
comment&code: //it might be an unwrapped collection reference! //try to find a wrapper (slowish)Iterator<PersistentCollection> wrappers = collectionEntries.keyIterator();
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758956015110016
---------------------------------
comment&code: //Custom SQL//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675875298678875
---------------------------------
comment&code: //tableName = mappings.getNamingStrategy().propertyToTableName( className, path );Table ownerTable = collection.getOwner().getTable();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675872877240181
---------------------------------
comment&code: // returnreturn c;
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758745536208153
---------------------------------
comment&code: // the entry will be removed after the flush, and will no longer // override the stale snapshot // This is now handled by removeEntity() in EntityDeleteAction //persistenceContext.removeDatabaseSnapshot(key);//session.getPersistenceContext().removeDatabaseSnapshot(key);
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675897277891636
---------------------------------
comment&code: //bad cast}
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758745536208153
---------------------------------
comment&code: "/*ArrayList list = new ArrayList();			list.addAll( getKey().getConstraintColumns() );			list.addAll( getIndex().getConstraintColumns() );			getCollectionTable().createUniqueKey(list);*/"list.add(baz);
true label: 0
predicted label: 0
non_satd_prob: 0.9832413196563721 satd_prob: 0.01675862818956375
---------------------------------
comment&code: //property-refs for associations defined on a //component are not supported, so no need to slicereturn lhsPersister.getPropertyColumnNames(propertyName);
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758903861045837
---------------------------------
comment&code: // we have an embedded composite identifiertry {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: //if there is no property-ref, assume the join //is to the subclass table (ie. the table of the //subclass that the association belongs to)return lhsPersister.getSubclassPropertyTableName(propertyIndex);
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758887097239494
---------------------------------
comment&code: //stops flush being called multiple times if this method is recursively calledtry {
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759028658270836
---------------------------------
comment&code: // Create a new FROM node for the referenced class.String associatedEntityName = propertyType.getAssociatedEntityName();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758769750595093
---------------------------------
comment&code: // performance op to avoid the array searchreturn 0;
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758818179368973
---------------------------------
comment&code: // now get an existing proxy for each row element (if there is one)for ( int i = 0; i < entitySpan; i++ ) {
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758928075432777
---------------------------------
comment&code: // ORPHAN DELETE (used for programmer error detection)Attribute cascadeAtt = node.attribute( "cascade" );
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675892062485218
---------------------------------
comment&code: // empty means no scopingreturn dialectScopes.isEmpty() || dialectScopes.contains( dialect.getClass().getName() );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675882562994957
---------------------------------
comment&code: //Enable for HHH-440, which we don't like:/*if ( type.isComponentType() && !propertyName.equals(rootPropertyName) ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675897277891636
---------------------------------
comment&code: //this.forceCacheRefresh = forceCacheRefresh;this.comment = comment;
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758903861045837
---------------------------------
comment&code: // this is a collection initializer, so we must create a collection // for each of the passed-in keys, to account for the possibility // that the collection is empty and has no rows in the result setCollectionPersister[] collectionPersisters = getCollectionPersisters();
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758989542722702
---------------------------------
comment&code: // an "embedded" component (composite ids and unique) // note that this does not handle nested componentsif ( component.getOwner().hasPojoRepresentation() ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675897277891636
---------------------------------
comment&code: // ALIASESinternalInitSubclassPropertyAliasesMap( null, model.getSubclassPropertyClosureIterator() );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758745536208153
---------------------------------
comment&code: // cache these since they are stateless // this one could even be static...private final BackrefSetter setter; // this one could even be static...
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759131103754044
---------------------------------
comment&code: // a nested composite elementbindComponent(
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758745536208153
---------------------------------
comment&code: //Must occur after resolving identifiers!if ( session.isEventSource() ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675880141556263
---------------------------------
comment&code: // Get the persister for the _subclass_final Loadable persister = (Loadable) getFactory().getEntityPersister( instanceEntityName );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675880141556263
---------------------------------
comment&code: // aliases for composite-id'sif ( getIdentifierType().isComponentType() ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: // Fetch embedded identifiers propertynames from the "virtual" identifier componentCompositeType componentId = ( CompositeType ) getIdentifierType();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675875298678875
---------------------------------
comment&code: // we need to grab the version value from the entity, otherwise // we have issues with generated-version entities that may have // multiple actions queued during the same flushversion = persister.getVersion( instance );
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759131103754044
---------------------------------
comment&code: // embedded composite ids ( alias.idname1, alias.idname2 )subclassPropertyAliases.put( idPropertyNames[i], new String[] { idAliases[i] } );
true label: 0
predicted label: 0
non_satd_prob: 0.9832413196563721 satd_prob: 0.016758691519498825
---------------------------------
comment&code: // NOTE: we need to do the wrap here even if its not "dirty", // because collections need wrapping but changes to _them_ // don't dirty the container. Also, for versioned data, we // need to wrap before calling searchForDirtyCollectionsWrapVisitor visitor = new WrapVisitor(session);
true label: 0
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759319230914116
---------------------------------
comment&code: // TODO: skip formulas?l++;
true label: 0
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759352758526802
---------------------------------
comment&code: // GUID support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/**
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758818179368973
---------------------------------
comment&code: // invokeinterface // invoke Enabled.getInterceptFieldCallback()code.addInvokeinterface( target_type_index, getterName, getter_desc, 1 );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675875298678875
---------------------------------
comment&code: // hibernate seems to ignore this type...registerColumnType( Types.BLOB, "BLOB" );
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758933663368225
---------------------------------
comment&code: //don't need filters for the static loadersuniqueKeyLoaders.put(
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675894297659397
---------------------------------
comment&code: // The user requested a "greater" (i.e. more restrictive) form of // pessimistic lockif ( entry.getStatus() != Status.MANAGED ) {
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758911311626434
---------------------------------
comment&code: //do two passes, for collection property-ref!initIdentifierPropertyPaths(mapping);
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675882562994957
---------------------------------
comment&code: "/*public boolean dropTemporaryTableAfterUse() {		//we have to, because postgres sets current tx		//to rollback only after a failed create table		return true;	}*/"if (obj == null)
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758956015110016
---------------------------------
comment&code: // select the correct row by either pk or rowidif ( useRowId ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: "//			optimizer = getFactory().getSettings().getBytecodeProvider().getReflectionOptimizer( //					mappedClass, getterNames, setterNames, propTypes //			);"default:
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: //TODO: eventually, rowIdName[j]}
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675911620259285
---------------------------------
comment&code: //include the discriminator and class-level where, but not filters.append( persister.filterFragment( getAlias(), Collections.EMPTY_MAP ) );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675880141556263
---------------------------------
comment&code: //lazy = !join;fetchStyle = join ? FetchMode.JOIN : FetchMode.SELECT;
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675882562994957
---------------------------------
comment&code: //not absolutely necessary, but helps for some //equals()/hashCode() implementationsif ( componentTuplizer.hasParentProperty() ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675904355943203
---------------------------------
comment&code: // this is a property of the table, which we are updatingupdate.addColumns( getPropertyColumnNames(i),
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758928075432777
---------------------------------
comment&code: // special shortcut for id properties, skip the join! // this must only occur at the _end_ of a path expressionmetadata.getServiceRegistry()
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758982092142105
---------------------------------
comment&code: "// IMPL NOTE : due to the delayed population of setters (setters cached // 		for performance), we really cannot pro0perly define equality for // 		this transformer"isNaturalKeyLookup = isLookupByNaturalKey;
true label: 0
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.016759201884269714
---------------------------------
comment&code: // ( (Column) ( (SimpleValue) ic.getIndex() ).getColumnIterator().next() // ).setNullable(false);.getColumnIterator() );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675872877240181
---------------------------------
comment&code: // we have a mapped identifier property and the root of // the incoming property path matched that identifier // propertyproperty = identifierProperty;
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758838668465614
---------------------------------
comment&code: // contained elements:Iterator iter = node.elementIterator();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675875298678875
---------------------------------
comment&code: // for non-inverse one-to-many, with a not-null fk, add a backref!String entityName = ( (OneToMany) collection.getElement() ).getReferencedEntityName();
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675887033343315
---------------------------------
comment&code: // mappings might contain either the "raw" extends name (in the case of // an entity-name mapping) or a FQN (in the case of a POJO mapping).if ( mappings.getClass( extendsName ) == null && mappings.getClass( getClassName( extendsName, mappings ) ) == null ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758818179368973
---------------------------------
comment&code: // for objects that came in via update()}
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758862882852554
---------------------------------
comment&code: //use dialect default propertiesfinal Properties properties = new Properties();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758736222982407
---------------------------------
comment&code: // increment the version number (if necessary)final Object nextVersion = getNextVersion(event);
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758818179368973
---------------------------------
comment&code: // The cache provider is needed when we either have second-level cache enabled // or query cache enabled.  Note that useSecondLevelCache is enabled by defaultsettings.setRegionFactory( createRegionFactory( properties, ( useSecondLevelCache || useQueryCache ), serviceRegistry ) );
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758928075432777
---------------------------------
comment&code: //information about all properties in class hierarchyprivate final String[] subclassPropertyNameClosure;
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: // Informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/**
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758760437369347
---------------------------------
comment&code: // we are using "all" or "dirty" property-based optimistic lockingboolean[] includeInWhere = entityMetamodel.getOptimisticLockStyle() == OptimisticLockStyle.ALL
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675887033343315
---------------------------------
comment&code: // orphans should be deleted during save/updatereturn true;
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758911311626434
---------------------------------
comment&code: // maybe a concrete SQLpropertyresult type, but Map is exactly what is required at the momentElement discriminatorResult = returnElement.element("return-discriminator");
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675897277891636
---------------------------------
comment&code: // for some reason the antlr.CommonAST initialization routines force // this method to get called twice.  The first time with an empty stringif ( StringHelper.isNotEmpty( s ) ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759099438786507
---------------------------------
comment&code: // do a checkboolean hasOrphanDelete = loadedPersister != null && loadedPersister.hasOrphanDelete();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: "//			sqlAliasSuffixes[i] = element.getColumnAliasSuffix();"includeInSelect[i] = !element.isFetch();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758736222982407
---------------------------------
comment&code: //materialize associations (and initialize the object) laterhydratedObjects.add( object );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675882562994957
---------------------------------
comment&code: "//	private ComponentTuplizerFactory componentTuplizerFactory; todo : HHH-3517 and HHH-1907"private Interceptor interceptor;
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675889641046524
---------------------------------
comment&code: // drop them in reverse order in case db needs it done that way...{
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759099438786507
---------------------------------
comment&code: // the owning entity may have been deleted and its identifier unset due to // identifier-rollback; in which case, try to look up its identifier from // the persistence contextif ( session.getFactory().getSettings().isIdentifierRollbackEnabled() ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758965328335762
---------------------------------
comment&code: // build an array with indices equal to the total number // of actual returns in the result Hibernate will return // for this query (scalars + non-scalars)resultRow = new Object[ columnProcessors.length ];
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758965328335762
---------------------------------
comment&code: "//	public ComponentTuplizerFactory getComponentTuplizerFactory() { //		return componentTuplizerFactory; //	}"* Iterate the entity mappings
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758838668465614
---------------------------------
comment&code: // Mckoi has no known variation of a "SELECT ... FOR UPDATE" syntax...if ( lockMode==LockMode.PESSIMISTIC_FORCE_INCREMENT) {
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675894297659397
---------------------------------
comment&code: // it is or was referenced _somewhere_boolean ownerChanged = loadedPersister != currentPersister ||				// if either its role changed,
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758928075432777
---------------------------------
comment&code: // nothing to do; even if the operand is a parameter, no way we could // infer an appropriate expected type hereprotected abstract BytecodeProvider buildBytecodeProvider();
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759099438786507
---------------------------------
comment&code: // the root of the incoming property path matched one // of the embedded composite identifier propertiesproperty = identifierProperty;
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675877720117569
---------------------------------
comment&code: // add normal propertiesfor ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: // serialization ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~private void writeObject(ObjectOutputStream oos) throws IOException {
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675884611904621
---------------------------------
comment&code: // add the discriminatorif ( j == 0 ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758736222982407
---------------------------------
comment&code: // handles arrays and newly instantiated collectionsreturn collectionType.getElementsIterator(collection, session);
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758818179368973
---------------------------------
comment&code: // if either its role changed,!currentPersister
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: // we will need to create new entries}
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758933663368225
---------------------------------
comment&code: // this piece is needed for usage in select clausesuper.setDataType(propertyType);
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675889641046524
---------------------------------
comment&code: // key is an entity involved with the operation performed by the listener; // value can be either a copy of the entity or the entity itselfprivate Map<Object,Object> copyToEntityMap = new IdentityHashMap<Object,Object>( 10 );
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675889641046524
---------------------------------
comment&code: // Get the names of the columns used to link between the collection // owner and the collection elements.String[] keyColumnNames = persister.getKeyColumnNames();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675880141556263
---------------------------------
comment&code: //let's assume that there is only one lazy fetch group, for now!return result;
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759099438786507
---------------------------------
comment&code: // more specifically : "? [op] datetime" //      1) if the operator is MINUS, the param needs to be of //          some datetime type //      2) if the operator is PLUS, the param needs to be of //          some numeric typeexpectedType = getType() == HqlSqlTokenTypes.PLUS ? StandardBasicTypes.DOUBLE : rhType;
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759052872657776
---------------------------------
comment&code: // don't even bother trying to read any furtherreturn null;
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675902120769024
---------------------------------
comment&code: // prepend value and type list with null for any positions before the wanted position.for ( int i = 0; i < position - size; i++ ) {
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758862882852554
---------------------------------
comment&code: //+ "_" + referencedColumnName not used for backward compatibility}
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758793964982033
---------------------------------
comment&code: // static helper methods ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/**
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758760437369347
---------------------------------
comment&code: // Base Expectation impls ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~public static class BasicExpectation implements Expectation {
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758911311626434
---------------------------------
comment&code: // this property belongs on the table and is to be insertedupdate.addColumns( getPropertyColumnNames(i),
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758887097239494
---------------------------------
comment&code: // need to extract the component values and check for subtype replacements...CompositeType componentType = ( CompositeType ) types[i];
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675884611904621
---------------------------------
comment&code: // add the primary keyif ( j == 0 && identityInsert ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675875298678875
---------------------------------
comment&code: // Impl Note: allows multiple collection fetches as long as the // entire fecthed graph still "points back" to a single // root entity for returnerrorIfDML();
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759036108851433
---------------------------------
comment&code: // delegate already handles PK columnsif ( getFactory().getSettings().isCommentsEnabled() ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675877720117569
---------------------------------
comment&code: //ie. e.status==DELETEDif ( LOG.isTraceEnabled() ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: // kept for backward compatibility until after the 3.1beta5 release of HA// TODO: is this still needed?
true label: 0
predicted label: 0
non_satd_prob: 0.9832406640052795 satd_prob: 0.016759352758526802
---------------------------------
comment&code: //if an exception occurs during flush, user must call rollback()transactionCoordinator().getTransactionContext().managedFlush();
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758903861045837
---------------------------------
comment&code: // Turn off includeSubclasses on all FromElements.FromClause from = getCurrentFromClause();
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.016758928075432777
---------------------------------
comment&code: // can't just return null here, since that would // cause an owning component to become nullreturn NOT_NULL_COLLECTION;
true label: 0
predicted label: 0
non_satd_prob: 0.9832407832145691 satd_prob: 0.01675925776362419
---------------------------------
comment&code: // the object is transient or detached// the entity is not associated with the session, so
true label: 0
predicted label: 0
non_satd_prob: 0.983241081237793 satd_prob: 0.01675894297659397
---------------------------------
comment&code: // Now update only the tables with dirty properties (and the table with the version number)if ( tableUpdateNeeded[j] ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758989542722702
---------------------------------
comment&code: // Render the SQL queryfinal PreparedStatement insert;
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758736222982407
---------------------------------
comment&code: // We must return a valid RDMS/RSA command from this method to // prevent RDMS/RSA from issuing *ERROR 400return "";
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675906963646412
---------------------------------
comment&code: // Write the values of fields onto the prepared statement - we MUST use the state at the time the // insert was issued (cos of foreign key constraints). Not necessarily the object's current statedehydrate( id, fields, null, notNull, propertyColumnInsertable, j, insert, session, index, false );
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675897277891636
---------------------------------
comment&code: // registerColumnType(Types.VARBINARY, "CHARACTER($l)"); // registerColumnType(Types.BLOB, "CHARACTER($l)" );  // For use prior to CP 11.0 // registerColumnType(Types.CLOB, "CHARACTER($l)" );// Dialect method overrides ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675877720117569
---------------------------------
comment&code: //a proxy cannot be transient and it breaks ForeignKeys.isTransient&& ForeignKeys.isTransient( childEntityName, child, null, session ) ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: //don't bother trying to update, we know there is no row there yetisRowToUpdate = false;
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759181395173073
---------------------------------
comment&code: // CHECKAttribute chNode = node.attribute( "check" );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758745536208153
---------------------------------
comment&code: //if all fields are null, we might need to delete existing rowisRowToUpdate = true;
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758965328335762
---------------------------------
comment&code: //note: updates to joined tables can't be batched...if ( useBatch && updateBatchKey == null ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675906963646412
---------------------------------
comment&code: // String Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~registerFunction( "ascii", new StandardSQLFunction( "ascii", StandardBasicTypes.INTEGER ) );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675875298678875
---------------------------------
comment&code: // starting indexfinal PreparedStatement update;
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758736222982407
---------------------------------
comment&code: // object have been loaded with setReadOnly(true); HHH-2236snapshot[ lazyPropertyNumbers[j] ] = lazyPropertyTypes[j].deepCopy( propValue, factory );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758769750595093
---------------------------------
comment&code: "//	private List collectionOwnerAliases = new ArrayList(); //	private List collectionAliases = new ArrayList(); //	private List collectionPersisters = new ArrayList(); //	private List collectionResults = new ArrayList();"List collectionOwners = new ArrayList();
true label: 0
predicted label: 0
non_satd_prob: 0.9832413196563721 satd_prob: 0.016758708283305168
---------------------------------
comment&code: // Write any appropriate versioning conditional parametersif ( useVersion && entityMetamodel.getOptimisticLockStyle() == OptimisticLockStyle.VERSION ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758793964982033
---------------------------------
comment&code: //check if the detached object being merged is the parentObject unmergedInstance = mergeMap.get( entityEntryInstance );
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758784651756287
---------------------------------
comment&code: //Render the SQL queryfinal PreparedStatement insert;
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675872877240181
---------------------------------
comment&code: // determine if the collection elements are entities...Type elementType = persister.getElementType();
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758760437369347
---------------------------------
comment&code: // Do the key. The key is immutable so we can use the _current_ object state - not necessarily // the state at the time the delete was issuedgetIdentifierType().nullSafeSet( delete, id, index, session );
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675902120769024
---------------------------------
comment&code: // Let return-propertys override whatever the persister has for aliases.columnAliases = ( String[] ) fieldResults.get(propertyName);
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.016758834943175316
---------------------------------
comment&code: // We should use the _current_ object state (ie. after any updates that occurred during flush)if ( useVersion ) {
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.01675906963646412
---------------------------------
comment&code: // might need to run a different filter entirely after the flush // because the collection role may have changedentry = persistenceContext.getCollectionEntryOrNull( collection );
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675902120769024
---------------------------------
comment&code: // amazingly, these two will work because AbstractCollection // uses iterator() to fill the arraypublic Object[] toArray() {
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.01675897277891636
---------------------------------
comment&code: // can't cache this stuff either (per-invocation) // we are given a map of user-alias -> lock mode // create a new map of sql-alias -> lock modefinal LockOptions lockOptions = parameters.getLockOptions();
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016759060323238373
---------------------------------
comment&code: "//note: dirtyFields==null means we had no snapshot, and we couldn't get one using select-before-update //	  oldFields==null just means we had no snapshot to begin with (we might have used select-before-update to get the dirtyFields)"final boolean[] tableUpdateNeeded = getTableUpdateNeeded( dirtyFields, hasDirtyCollection );
true label: 0
predicted label: 0
non_satd_prob: 0.9832409024238586 satd_prob: 0.016759123653173447
---------------------------------
comment&code: // loop through all the associations of the current entity and make sure that they are processed // before the current batch numberObject[] propertyValues = action.getState();
true label: 0
predicted label: 0
non_satd_prob: 0.9832409620285034 satd_prob: 0.016758989542722702
---------------------------------
comment&code: 
true label: 0
predicted label: 0
non_satd_prob: 0.9832412004470825 satd_prob: 0.01675875298678875
